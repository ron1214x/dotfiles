var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs5 = require("fs");
  function checkPathExt(path5, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path5.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path5, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path5, options);
  }
  function isexe(path5, options, cb) {
    fs5.stat(path5, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path5, options));
    });
  }
  function sync(path5, options) {
    return checkStat(fs5.statSync(path5), path5, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs5 = require("fs");
  function isexe(path5, options, cb) {
    fs5.stat(path5, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path5, options) {
    return checkStat(fs5.statSync(path5), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var core2;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core2 = require_windows();
  } else {
    core2 = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path5, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path5, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core2(path5, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path5, options) {
    try {
      return core2.sync(path5, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path5 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which3 = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path5.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path5.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which3;
  which3.sync = whichSync;
});

// node_modules/unibeautify/dist/src/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function zipObject(keys, values) {
    return keys.reduce((acc, key, idx) => Object.assign({}, acc, {[key]: values[idx]}), {});
  }
  exports2.zipObject = zipObject;
  function unique(array) {
    return array.reduce((acc, val) => acc.indexOf(val) === -1 ? acc.concat(val) : acc, []);
  }
  exports2.unique = unique;
  function filterMultiCriteria(array, filters) {
    return array.filter((arr) => Object.keys(filters).some((key) => {
      if (arr[key] || filters[key]) {
        if (Array.isArray(arr[key])) {
          return filters[key] && arr[key].indexOf(filters[key]) !== -1;
        }
        return arr[key] === filters[key];
      }
      return false;
    }));
  }
  exports2.filterMultiCriteria = filterMultiCriteria;
});

// node_modules/unibeautify/dist/src/LanguageManager.js
var require_LanguageManager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var utils_1 = require_utils();
  var LanguageManager = class {
    constructor(languages2) {
      this.languages = languages2;
    }
    getLanguage(data) {
      const filters = {
        atomGrammars: data.atomGrammar,
        extensions: data.fileExtension,
        name: data.languageName,
        sublimeSyntaxes: data.sublimeSyntax,
        vscodeLanguages: data.vscodeLanguage
      };
      const langs = this.findLanguages({
        atomGrammar: data.atomGrammar,
        extension: data.fileExtension,
        name: data.languageName,
        sublimeSyntax: data.sublimeSyntax,
        vscodeLanguage: data.vscodeLanguage
      });
      return this.getBestMatchLanguage(langs, filters);
    }
    findLanguages(query) {
      const filters = {
        name: query.name,
        namespace: query.namespace,
        extensions: query.extension,
        atomGrammars: query.atomGrammar,
        sublimeSyntaxes: query.sublimeSyntax,
        vscodeLanguages: query.vscodeLanguage
      };
      const langs = utils_1.filterMultiCriteria(this.languages, filters);
      return utils_1.unique(langs);
    }
    getBestMatchLanguage(langs, filters) {
      let bestMatch = langs[0];
      let highest = 0;
      const keys = Object.keys(filters);
      langs.forEach((lang) => {
        let score = 0;
        keys.forEach((key) => {
          const value = lang[key];
          if (Array.isArray(value)) {
            if (filters[key] && value.indexOf(filters[key]) !== -1) {
              score = score + 1;
            }
          } else if (filters[key] === lang[key]) {
            score = score + 1;
          }
        });
        if (score > highest) {
          bestMatch = lang;
          highest = score;
        }
      });
      return bestMatch;
    }
    getLoadedLanguages() {
      return this.languages.slice();
    }
    loadLanguage(language) {
      this.languages.push(language);
      return this;
    }
    loadLanguages(languages2) {
      this.languages.push(...languages2);
      return this;
    }
  };
  exports2.LanguageManager = LanguageManager;
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports2, module2) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs2 = data.__data__;
          if (!Map || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs2);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path5) {
        path5 = castPath(path5, object);
        var index = 0, length = path5.length;
        while (object != null && index < length) {
          object = object[toKey(path5[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path5, args) {
        path5 = castPath(path5, object);
        object = parent(object, path5);
        var func = object == null ? object : object[toKey(last(path5))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path5, srcValue) {
        if (isKey(path5) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path5), srcValue);
        }
        return function(object) {
          var objValue = get(object, path5);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path5) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index, value};
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path5) {
          return hasIn(object, path5);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path5 = paths[index], value = baseGet(object, path5);
          if (predicate(value, path5)) {
            baseSet(result2, castPath(path5, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path5) {
        return function(object) {
          return baseGet(object, path5);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path5, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path5 = castPath(path5, object);
        var index = -1, length = path5.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path5[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject2(objValue) ? objValue : isIndex(path5[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path5) {
        path5 = castPath(path5, object);
        object = parent(object, path5);
        return object == null || delete object[toKey(last(path5))];
      }
      function baseUpdate(object, path5, updater, customizer) {
        return baseSet(object, path5, updater(baseGet(object, path5)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path5, hasFunc) {
        path5 = castPath(path5, object);
        var index = -1, length = path5.length, result2 = false;
        while (++index < length) {
          var key = toKey(path5[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path5) {
        return path5.length < 2 ? object : baseGet(object, baseSlice(path5, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs2) {
        var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
        while (++index < length) {
          var pair = pairs2[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path5, args) {
        var index = -1, isFunc = typeof path5 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path5, value, args) : baseInvoke(value, path5, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull2(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary2 = reIsBinary.test(value);
        return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path5, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path5);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path5) {
        return object != null && hasPath(object, path5, baseHas);
      }
      function hasIn(object, path5) {
        return object != null && hasPath(object, path5, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path5) {
          path5 = castPath(path5, object);
          isDeep || (isDeep = path5.length > 1);
          return path5;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path5) {
          return predicate(value, path5[0]);
        });
      }
      function result(object, path5, defaultValue) {
        path5 = castPath(path5, object);
        var index = -1, length = path5.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path5[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path5, value) {
        return object == null ? object : baseSet(object, path5, value);
      }
      function setWith(object, path5, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path5, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path5) {
        return object == null ? true : baseUnset(object, path5);
      }
      function update(object, path5, updater) {
        return object == null ? object : baseUpdate(object, path5, castFunction(updater));
      }
      function updateWith(object, path5, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path5, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart2(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs2) {
        var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
        pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs2[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path5, srcValue) {
        return baseMatchesProperty(path5, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path5, args) {
        return function(object) {
          return baseInvoke(object, path5, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path5) {
          return baseInvoke(object, path5, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path5) {
        return isKey(path5) ? baseProperty(toKey(path5)) : basePropertyDeep(path5);
      }
      function propertyOf(object) {
        return function(path5) {
          return object == null ? undefined2 : baseGet(object, path5);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map2;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge2;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set2;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray2;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean2;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger2;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull2;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject2;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart2;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat2;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString2;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path5, args) {
        if (typeof path5 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path5, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports2);
});

// node_modules/unibeautify/dist/src/OptionsManager.js
var require_OptionsManager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _ = require_lodash();
  var OptionsManager = class {
    constructor(options) {
      this.options = options;
    }
    get loadedOptions() {
      return Object.assign({}, this.options);
    }
    loadOptions(options) {
      _.merge(this.options, options);
      return this;
    }
  };
  exports2.OptionsManager = OptionsManager;
  function optionKeys(beautifier, language) {
    const beautifierOptions = beautifier.options[language.name];
    if (typeof beautifierOptions === "boolean") {
      return [];
    } else if (typeof beautifierOptions === "object") {
      const options = [];
      Object.keys(beautifierOptions).forEach((fieldKey) => {
        const op = beautifierOptions[fieldKey];
        if (typeof op === "string") {
          options.push(op);
        } else if (isOptionTransformSingleFunction(op)) {
          options.push(fieldKey);
        } else if (typeof op === "boolean") {
          if (op === true) {
            options.push(fieldKey);
          }
        } else if (isOptionTransform(op)) {
          options.push(...op[0]);
        } else {
          return new Error(`Invalid option "${fieldKey}" with value ${JSON.stringify(op)}.`);
        }
      });
      return options;
    } else {
      return [];
    }
  }
  exports2.optionKeys = optionKeys;
  function isOptionTransformSingleFunction(option) {
    return typeof option === "function";
  }
  function isOptionTransform(option) {
    return Array.isArray(option);
  }
});

// node_modules/diff/lib/index.es6.js
var require_index_es6 = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    Diff: () => Diff,
    applyPatch: () => applyPatch,
    applyPatches: () => applyPatches,
    canonicalize: () => canonicalize,
    convertChangesToDMP: () => convertChangesToDMP,
    convertChangesToXML: () => convertChangesToXML,
    createPatch: () => createPatch,
    createTwoFilesPatch: () => createTwoFilesPatch,
    diffArrays: () => diffArrays,
    diffChars: () => diffChars,
    diffCss: () => diffCss,
    diffJson: () => diffJson,
    diffLines: () => diffLines,
    diffSentences: () => diffSentences,
    diffTrimmedLines: () => diffTrimmedLines,
    diffWords: () => diffWords,
    diffWordsWithSpace: () => diffWordsWithSpace,
    merge: () => merge2,
    parsePatch: () => parsePatch,
    structuredPatch: () => structuredPatch
  });
  function Diff() {
  }
  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = options.callback;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      this.options = options;
      var self2 = this;
      function done(value) {
        if (callback) {
          setTimeout(function() {
            callback(void 0, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      }
      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length, oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }];
      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      }
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;
          var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
          if (addPath) {
            bestPath[diagonalPath - 1] = void 0;
          }
          var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
          if (!canAdd && !canRemove) {
            bestPath[diagonalPath] = void 0;
            continue;
          }
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self2.pushComponent(basePath.components, void 0, true);
          } else {
            basePath = addPath;
            basePath.newPos++;
            self2.pushComponent(basePath.components, true, void 0);
          }
          _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
          } else {
            bestPath[diagonalPath] = basePath;
          }
        }
        editLength++;
      }
      if (callback) {
        (function exec2() {
          setTimeout(function() {
            if (editLength > maxEditLength) {
              return callback();
            }
            if (!execEditLength()) {
              exec2();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];
      if (last && last.added === added && last.removed === removed) {
        components[components.length - 1] = {
          count: last.count + 1,
          added,
          removed
        };
      } else {
        components.push({
          count: 1,
          added,
          removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }
      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }
      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];
      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }
      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split("");
    },
    join: function join(chars) {
      return chars.join("");
    }
  };
  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];
      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    }
    var lastComponent = components[componentLen - 1];
    if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }
    return components;
  }
  function clonePath(path5) {
    return {
      newPos: path5.newPos,
      components: path5.components.slice(0)
    };
  }
  var characterDiff = new Diff();
  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }
  function generateOptions(options, defaults) {
    if (typeof options === "function") {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }
    return defaults;
  }
  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();
  wordDiff.equals = function(left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };
  wordDiff.tokenize = function(value) {
    var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/);
    for (var i = 0; i < tokens.length - 1; i++) {
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }
    return tokens;
  };
  function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
      ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
  }
  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }
  var lineDiff = new Diff();
  lineDiff.tokenize = function(value) {
    var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    }
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];
      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }
        retLines.push(line);
      }
    }
    return retLines;
  };
  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }
  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
      ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
  }
  var sentenceDiff = new Diff();
  sentenceDiff.tokenize = function(value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }
  var cssDiff = new Diff();
  cssDiff.tokenize = function(value) {
    return value.split(/([{}:;,]|\s+)/);
  };
  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    }
  }
  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
      return Array.from(iter);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff();
  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;
  jsonDiff.castInput = function(value) {
    var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
      return typeof v === "undefined" ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
  };
  jsonDiff.equals = function(left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
  };
  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  }
  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];
    if (replacer) {
      obj = replacer(key, obj);
    }
    var i;
    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }
    var canonicalizedObj;
    if (objectPrototypeToString.call(obj) === "[object Array]") {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);
      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }
      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }
    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }
    if (_typeof(obj) === "object" && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);
      var sortedKeys = [], _key;
      for (_key in obj) {
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }
      sortedKeys.sort();
      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }
      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }
    return canonicalizedObj;
  }
  var arrayDiff = new Diff();
  arrayDiff.tokenize = function(value) {
    return value.slice();
  };
  arrayDiff.join = arrayDiff.removeEmpty = function(value) {
    return value;
  };
  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }
  function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
    function parseIndex() {
      var index = {};
      list.push(index);
      while (i < diffstr.length) {
        var line = diffstr[i];
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        }
        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
        if (header) {
          index.index = header[1];
        }
        i++;
      }
      parseFileHeader(index);
      parseFileHeader(index);
      index.hunks = [];
      while (i < diffstr.length) {
        var _line = diffstr[i];
        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    }
    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
      if (fileHeader) {
        var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
        var data = fileHeader[2].split("	", 2);
        var fileName = data[0].replace(/\\\\/g, "\\");
        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }
        index[keyPrefix + "FileName"] = fileName;
        index[keyPrefix + "Header"] = (data[1] || "").trim();
        i++;
      }
    }
    function parseHunk() {
      var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      };
      var addCount = 0, removeCount = 0;
      for (; i < diffstr.length; i++) {
        if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
          break;
        }
        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
        if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || "\n");
          if (operation === "+") {
            addCount++;
          } else if (operation === "-") {
            removeCount++;
          } else if (operation === " ") {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      }
      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }
      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      }
      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
        }
        if (removeCount !== hunk.oldLines) {
          throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
        }
      }
      return hunk;
    }
    while (i < diffstr.length) {
      parseIndex();
    }
    return list;
  }
  function distanceIterator(start, minLine, maxLine) {
    var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        }
        if (start + localOffset <= maxLine) {
          return localOffset;
        }
        forwardExhausted = true;
      }
      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        }
        if (minLine <= start - localOffset) {
          return -localOffset++;
        }
        backwardExhausted = true;
        return iterator();
      }
    };
  }
  function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof uniDiff === "string") {
      uniDiff = parsePatch(uniDiff);
    }
    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error("applyPatch only works with a single input.");
      }
      uniDiff = uniDiff[0];
    }
    var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
      return line2 === patchContent;
    }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
    function hunkFits(hunk2, toPos2) {
      for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
        var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
        if (operation2 === " " || operation2 === "-") {
          if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
            errorCount++;
            if (errorCount > fuzzFactor) {
              return false;
            }
          }
          toPos2++;
        }
      }
      return true;
    }
    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);
      for (; localOffset !== void 0; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }
      if (localOffset === void 0) {
        return false;
      }
      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    }
    var diffOffset = 0;
    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
      diffOffset += _hunk.newLines - _hunk.oldLines;
      if (_toPos < 0) {
        _toPos = 0;
      }
      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
        if (operation === " ") {
          _toPos++;
        } else if (operation === "-") {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
        } else if (operation === "+") {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === "\\") {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
          if (previousOperation === "+") {
            removeEOFNL = true;
          } else if (previousOperation === "-") {
            addEOFNL = true;
          }
        }
      }
    }
    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push("");
      delimiters.push("\n");
    }
    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }
    return lines.join("");
  }
  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === "string") {
      uniDiff = parsePatch(uniDiff);
    }
    var currentIndex = 0;
    function processIndex() {
      var index = uniDiff[currentIndex++];
      if (!index) {
        return options.complete();
      }
      options.loadFile(index, function(err, data) {
        if (err) {
          return options.complete(err);
        }
        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function(err2) {
          if (err2) {
            return options.complete(err2);
          }
          processIndex();
        });
      });
    }
    processIndex();
  }
  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }
    if (typeof options.context === "undefined") {
      options.context = 4;
    }
    var diff = diffLines(oldStr, newStr, options);
    diff.push({
      value: "",
      lines: []
    });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    var hunks = [];
    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    var _loop = function _loop2(i2) {
      var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
      current.lines = lines;
      if (current.added || current.removed) {
        var _curRange;
        if (!oldRangeStart) {
          var prev = diff[i2 - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
          return (current.added ? "+" : "-") + entry;
        })));
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
            var _curRange2;
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3;
            var contextSize = Math.min(lines.length, options.context);
            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            if (i2 >= diff.length - 2 && lines.length <= options.context) {
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
              if (!oldEOFNewline && noNlBeforeAdds) {
                curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
              }
              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                curRange.push("\\ No newline at end of file");
              }
            }
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    };
    for (var i = 0; i < diff.length; i++) {
      _loop(i);
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    var ret = [];
    if (oldFileName == newFileName) {
      ret.push("Index: " + oldFileName);
    }
    ret.push("===================================================================");
    ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
    ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i];
      ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
      ret.push.apply(ret, hunk.lines);
    }
    return ret.join("\n") + "\n";
  }
  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }
  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    return arrayStartsWith(a, b);
  }
  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }
    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
    if (oldLines !== void 0) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }
    if (newLines !== void 0) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }
  function merge2(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {};
    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }
    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }
    ret.hunks = [];
    var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || {
        oldStart: Infinity
      }, theirsCurrent = theirs.hunks[theirsIndex] || {
        oldStart: Infinity
      };
      if (hunkBefore(mineCurrent, theirsCurrent)) {
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;
        ret.hunks.push(mergedHunk);
      }
    }
    return ret;
  }
  function loadPatch(param, base) {
    if (typeof param === "string") {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return parsePatch(param)[0];
      }
      if (!base) {
        throw new Error("Must provide a base reference or pass in a patch");
      }
      return structuredPatch(void 0, void 0, base, param);
    }
    return param;
  }
  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }
  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return {
        mine,
        theirs
      };
    }
  }
  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }
  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset,
      newLines: hunk.newLines,
      lines: hunk.lines
    };
  }
  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    var mine = {
      offset: mineOffset,
      lines: mineLines,
      index: 0
    }, their = {
      offset: theirOffset,
      lines: theirLines,
      index: 0
    };
    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine);
    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
      if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
        var _hunk$lines;
        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
      } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
        var _hunk$lines2;
        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
      } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    }
    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
  }
  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine), theirChanges = collectChange(their);
    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        var _hunk$lines3;
        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
        return;
      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        var _hunk$lines4;
        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
        return;
      }
    } else if (arrayEqual(myChanges, theirChanges)) {
      var _hunk$lines5;
      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
      return;
    }
    conflict(hunk, myChanges, theirChanges);
  }
  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
    if (theirChanges.merged) {
      var _hunk$lines6;
      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }
  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine,
      theirs: their
    });
  }
  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }
  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }
  function collectChange(state) {
    var ret = [], operation = state.lines[state.index][0];
    while (state.index < state.lines.length) {
      var line = state.lines[state.index];
      if (operation === "-" && line[0] === "+") {
        operation = "+";
      }
      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }
    return ret;
  }
  function collectContext(state, matchChanges) {
    var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index], match = matchChanges[matchIndex];
      if (match[0] === "+") {
        break;
      }
      contextChanges = contextChanges || change[0] !== " ";
      merged.push(match);
      matchIndex++;
      if (change[0] === "+") {
        conflicted = true;
        while (change[0] === "+") {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }
      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }
    if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
      conflicted = true;
    }
    if (conflicted) {
      return changes;
    }
    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }
    return {
      merged,
      changes
    };
  }
  function allRemoves(changes) {
    return changes.reduce(function(prev, change) {
      return prev && change[0] === "-";
    }, true);
  }
  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
      if (state.lines[state.index + i] !== " " + changeContent) {
        return false;
      }
    }
    state.index += delta;
    return true;
  }
  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function(line) {
      if (typeof line !== "string") {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);
        if (oldLines !== void 0) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = void 0;
          }
        }
        if (newLines !== void 0) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = void 0;
          }
        }
      } else {
        if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
          newLines++;
        }
        if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
          oldLines++;
        }
      }
    });
    return {
      oldLines,
      newLines
    };
  }
  function convertChangesToDMP(changes) {
    var ret = [], change, operation;
    for (var i = 0; i < changes.length; i++) {
      change = changes[i];
      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }
      ret.push([operation, change.value]);
    }
    return ret;
  }
  function convertChangesToXML(changes) {
    var ret = [];
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      if (change.added) {
        ret.push("<ins>");
      } else if (change.removed) {
        ret.push("<del>");
      }
      ret.push(escapeHTML(change.value));
      if (change.added) {
        ret.push("</ins>");
      } else if (change.removed) {
        ret.push("</del>");
      }
    }
    return ret.join("");
  }
  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, "&amp;");
    n = n.replace(/</g, "&lt;");
    n = n.replace(/>/g, "&gt;");
    n = n.replace(/"/g, "&quot;");
    return n;
  }
});

// node_modules/unibeautify/dist/src/InlineFlagManager.js
var require_InlineFlagManager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var diff_1 = require_index_es6();
  var InlineFlagManager = class {
    constructor(oldText, newText) {
      this.oldText = oldText;
      this.newText = newText;
      this.oldLines = [];
      this.oldLines = oldText.split("\n");
      this.containsDisable = this.oldText.indexOf(InlineFlagPrefix.Disable) !== -1;
    }
    get text() {
      const {patch, oldText} = this;
      const afterPatchText = diff_1.applyPatch(oldText, patch);
      return this.fixEndOfFile(afterPatchText);
    }
    fixEndOfFile(text) {
      const shouldEndWithNewline = this.endsWithNewline(this.newText);
      const afterEndsWithNewline = this.endsWithNewline(text);
      if (shouldEndWithNewline === afterEndsWithNewline) {
        return text;
      }
      if (shouldEndWithNewline) {
        return `${text}
`;
      }
      return text.slice(0, -1);
    }
    endsWithNewline(text) {
      return text.charAt(text.length - 1) === "\n";
    }
    get patch() {
      const {rawPatch} = this;
      const filteredHunks = this.filterHunks(rawPatch.hunks);
      return Object.assign({}, rawPatch, {hunks: filteredHunks});
    }
    get rawPatch() {
      const oldFileName = "Old";
      const newFileName = "New";
      const oldHeader = "";
      const newHeader = "";
      const options = {
        context: 0
      };
      return diff_1.parsePatch(diff_1.createTwoFilesPatch(oldFileName, newFileName, this.oldText, this.newText, oldHeader, newHeader, options))[0];
    }
    filterHunks(hunks) {
      return hunks.filter(this.shouldApplyHunk.bind(this));
    }
    shouldApplyHunk(hunk) {
      const lineNumber = hunk.oldStart;
      return !(this.shouldIgnoreThisLine(lineNumber) || this.isDisabledAtLine(lineNumber));
    }
    shouldIgnoreThisLine(lineNumber) {
      const prevLineNum = lineNumber - 1;
      const prevLineCode = this.codeAtLine(prevLineNum);
      return Boolean(prevLineCode && prevLineCode.indexOf(InlineFlagPrefix.IgnoreNextLine) !== -1);
    }
    isDisabledAtLine(lineNumber) {
      if (this.containsDisable) {
        const reversedLines = this.oldLines.slice(0, Math.max(0, lineNumber)).reverse().join("\n");
        const disableIndex = reversedLines.indexOf(InlineFlagPrefix.Disable);
        const enableIndex = reversedLines.indexOf(InlineFlagPrefix.Enable);
        if (disableIndex !== -1 && (enableIndex === -1 || disableIndex < enableIndex)) {
          return true;
        }
      }
      return false;
    }
    codeAtLine(lineNumber) {
      return this.oldLines[Math.max(0, lineNumber - 1)];
    }
  };
  exports2.InlineFlagManager = InlineFlagManager;
  var InlineFlagPrefix;
  (function(InlineFlagPrefix2) {
    InlineFlagPrefix2["IgnoreNextLine"] = "unibeautify:ignore-next-line";
    InlineFlagPrefix2["Enable"] = "unibeautify:enable";
    InlineFlagPrefix2["Disable"] = "unibeautify:disable";
  })(InlineFlagPrefix || (InlineFlagPrefix = {}));
});

// node_modules/unibeautify/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range5(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range5(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range5;
  function Range5(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range5) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range5(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range5(range.value, options);
    }
    if (!(this instanceof Range5)) {
      return new Range5(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range5.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range5.prototype.toString = function() {
    return this.range;
  };
  Range5.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set2 = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set2 = set2.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set2 = set2.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set2;
  };
  Range5.prototype.intersects = function(range, options) {
    if (!(range instanceof Range5)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range5(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range5.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set2, version, options) {
    for (var i2 = 0; i2 < set2.length; i2++) {
      if (!set2[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set2.length; i2++) {
        debug(set2[i2].semver);
        if (set2[i2].semver === ANY) {
          continue;
        }
        if (set2[i2].semver.prerelease.length > 0) {
          var allowed = set2[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range5(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range5(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range5(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range5(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range5(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range5(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range5(r1, options);
    r2 = new Range5(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// node_modules/unibeautify/dist/src/DependencyManager/Version.js
var require_Version = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var SemVer = require_semver();
  var Version = class {
    constructor(rawVersion) {
      this.rawVersion = rawVersion;
      this.semVer = new SemVer.SemVer(SemVer.coerce(this.rawVersion) || this.rawVersion, true);
    }
    isGreaterThan(anotherVersion) {
      return SemVer.gt(this.semVer, anotherVersion);
    }
    satisfies(ranger) {
      return SemVer.satisfies(this.semVer, ranger);
    }
    get major() {
      return this.semVer.major;
    }
    get minor() {
      return this.semVer.minor;
    }
    get patch() {
      return this.semVer.patch;
    }
  };
  exports2.Version = Version;
});

// node_modules/unibeautify/dist/src/DependencyManager/Dependency.js
var require_Dependency = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Version_1 = require_Version();
  var Dependency = class {
    constructor(definition, options) {
      this.definition = definition;
      this.options = options;
      this._isInstalled = false;
      this._errors = [];
    }
    load() {
      if (this.isInstalled) {
        return Promise.resolve(this.isInstalled);
      }
      return this.reload();
    }
    reload() {
      this.clearErrors();
      return this.loadVersion().then((version) => {
        this._version = this.parseVersion(version);
        return this._isInstalled = true;
      }).catch((error) => {
        this.addError(error);
        this._version = void 0;
        return this._isInstalled = false;
      }).then((isInstalled) => {
        if (this.required && !isInstalled) {
          throw new Error([
            `Dependency "${this.name}" is required and not installed.`,
            ...this.errors.map((error) => `  - ${error.message}`)
          ].join("\n"));
        }
        return isInstalled;
      });
    }
    parseVersion(text) {
      return new Version_1.Version(this.versionFromText(text) || "");
    }
    versionFromText(text) {
      const {parseVersion} = this.definition;
      if (!parseVersion) {
        return text;
      }
      if (typeof parseVersion === "function") {
        return parseVersion(text);
      }
      const patterns = Array.isArray(parseVersion) ? parseVersion : [parseVersion];
      return this.extractWithPatterns(text, patterns) || "";
    }
    extractWithPatterns(text, patterns) {
      return patterns.reduce((extracted, pattern) => {
        if (extracted) {
          return extracted;
        }
        const expr = typeof pattern === "string" ? new RegExp(pattern) : pattern;
        const matches = text.match(expr);
        if (matches) {
          return matches[1];
        }
        return void 0;
      }, void 0);
    }
    get isInstalled() {
      return this._isInstalled;
    }
    addError(error) {
      this._errors.push(error);
    }
    clearErrors() {
      this._errors = [];
    }
    get name() {
      return this.definition.name;
    }
    get required() {
      return !Boolean(this.definition.optional);
    }
    get version() {
      return this._version;
    }
    get errors() {
      return this._errors;
    }
  };
  exports2.Dependency = Dependency;
  var DependencyType;
  (function(DependencyType2) {
    DependencyType2["Node"] = "node";
    DependencyType2["Executable"] = "exec";
  })(DependencyType = exports2.DependencyType || (exports2.DependencyType = {}));
});

// node_modules/resolve/lib/core.json
var require_core = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debugger: "< 8",
    dgram: true,
    dns: true,
    domain: true,
    events: true,
    freelist: "< 6",
    fs: true,
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0",
    os: true,
    path: true,
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    string_decoder: true,
    sys: true,
    timers: true,
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    tty: true,
    url: true,
    util: true,
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0"],
    v8: ">= 1",
    vm: true,
    zlib: true
  };
});

// node_modules/resolve/lib/core.js
var require_core2 = __commonJS((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts[0];
    var versionParts = parts[1].split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = Number(current[i] || 0);
      var ver = Number(versionParts[i] || 0);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      } else {
        return false;
      }
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core();
  var core2 = {};
  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core2[mod] = versionIncluded(data[mod]);
    }
  }
  module2.exports = core2;
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports2, module2) => {
  "use strict";
  var isWindows = process.platform === "win32";
  var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
  var win32 = {};
  function win32SplitPath(filename) {
    var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
    var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
    return [device, dir, basename, ext];
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    allParts[1] = allParts[1] || "";
    allParts[2] = allParts[2] || "";
    allParts[3] = allParts[3] || "";
    return {
      root: allParts[0],
      dir: allParts[0] + allParts[1].slice(0, -1),
      base: allParts[2],
      ext: allParts[3],
      name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
  };
  if (isWindows)
    module2.exports = win32.parse;
  else
    module2.exports = posix.parse;
  module2.exports.posix = posix.parse;
  module2.exports.win32 = win32.parse;
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports2, module2) => {
  var path5 = require("path");
  var fs5 = require("fs");
  var parse = path5.parse || require_path_parse();
  module2.exports = function nodeModulesPaths(start, opts) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    var absoluteStart = path5.resolve(start);
    if (opts && opts.preserveSymlinks === false) {
      try {
        absoluteStart = fs5.realpathSync(absoluteStart);
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    var dirs = paths.reduce(function(dirs2, aPath) {
      return dirs2.concat(modules.map(function(moduleDir) {
        return path5.join(prefix, aPath, moduleDir);
      }));
    }, []);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var core2 = require_core2();
  var fs5 = require("fs");
  var path5 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var defaultIsFile = function isFile(file, cb) {
    fs5.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  module2.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options || {};
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    var isFile = opts.isFile || defaultIsFile;
    var readFile = opts.readFile || fs5.readFile;
    var extensions = opts.extensions || [".js"];
    var basedir = opts.basedir || path5.dirname(caller());
    opts.paths = opts.paths || [];
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path5.resolve(basedir, x);
      if (x === ".." || x.slice(-1) === "/")
        res += "/";
      if (/\/$/.test(x) && res === basedir) {
        loadAsDirectory(res, opts.package, onfile);
      } else
        loadAsFile(res, opts.package, onfile);
    } else
      loadNodeModules(x, basedir, function(err2, n, pkg) {
        if (err2)
          cb(err2);
        else if (n)
          cb(null, n, pkg);
        else if (core2[x])
          return cb(null, x);
        else {
          var moduleError = new Error("Cannot find module '" + x + "' from '" + basedir + "'");
          moduleError.code = "MODULE_NOT_FOUND";
          cb(moduleError);
        }
      });
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d)
            cb(null, d, pkg2);
          else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + basedir + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load2(exts, x2, loadAsFilePackage);
      function load2(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path5.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path5.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load2([""].concat(extensions.slice()), path5.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load2(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      var pkgfile = path5.join(dir, "package.json");
      isFile(pkgfile, function(err2, ex) {
        if (!ex)
          return loadpkg(path5.dirname(dir), cb2);
        readFile(pkgfile, function(err3, body) {
          if (err3)
            cb2(err3);
          try {
            var pkg = JSON.parse(body);
          } catch (jsonErr) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }
          cb2(null, pkg, dir);
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      var pkgfile = path5.join(x2, "package.json");
      isFile(pkgfile, function(err2, ex) {
        if (err2)
          return cb2(err2);
        if (!ex)
          return loadAsFile(path5.join(x2, "index"), fpkg, cb2);
        readFile(pkgfile, function(err3, body) {
          if (err3)
            return cb2(err3);
          try {
            var pkg = JSON.parse(body);
          } catch (jsonErr) {
          }
          if (opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile);
          }
          if (pkg.main) {
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            loadAsFile(path5.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
              if (err4)
                return cb2(err4);
              if (m)
                return cb2(null, m, pkg2);
              if (!pkg2)
                return loadAsFile(path5.join(x2, "index"), pkg2, cb2);
              var dir = path5.resolve(x2, pkg2.main);
              loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                if (err5)
                  return cb2(err5);
                if (n)
                  return cb2(null, n, pkg3);
                loadAsFile(path5.join(x2, "index"), pkg3, cb2);
              });
            });
            return;
          }
          loadAsFile(path5.join(x2, "/index"), pkg, cb2);
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      var file = path5.join(dir, x);
      loadAsFile(file, opts.package, onfile2);
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(path5.join(dir, x), opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      processDirs(cb2, nodeModulesPaths(start, opts));
    }
  };
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports2, module2) => {
  var core2 = require_core2();
  var fs5 = require("fs");
  var path5 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs5.statSync(file);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isFile() || stat.isFIFO();
  };
  module2.exports = function(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = options || {};
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs5.readFileSync;
    var extensions = opts.extensions || [".js"];
    var basedir = opts.basedir || path5.dirname(caller());
    opts.paths = opts.paths || [];
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path5.resolve(basedir, x);
      if (x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return m;
    } else {
      var n = loadNodeModulesSync(x, basedir);
      if (n)
        return n;
    }
    if (core2[x])
      return x;
    var err = new Error("Cannot find module '" + x + "' from '" + basedir + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path5.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path5.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path5.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path5.join(dir, "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path5.dirname(dir));
      }
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
      } catch (jsonErr) {
      }
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return {pkg, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path5.join(x2, "/package.json");
      if (isFile(pkgfile)) {
        try {
          var body = readFileSync(pkgfile, "UTF8");
          var pkg = JSON.parse(body);
          if (opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg.main) {
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            var m2 = loadAsFileSync(path5.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path5.resolve(x2, pkg.main));
            if (n2)
              return n2;
          }
        } catch (e) {
        }
      }
      return loadAsFileSync(path5.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var dirs = nodeModulesPaths(start, opts);
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        var m2 = loadAsFileSync(path5.join(dir, "/", x2));
        if (m2)
          return m2;
        var n2 = loadAsDirectorySync(path5.join(dir, "/", x2));
        if (n2)
          return n2;
      }
    }
  };
});

// node_modules/resolve/index.js
var require_resolve = __commonJS((exports2, module2) => {
  var core2 = require_core2();
  var async = require_async();
  async.core = core2;
  async.isCore = function isCore(x) {
    return core2[x];
  };
  async.sync = require_sync();
  exports2 = async;
  module2.exports = async;
});

// node_modules/ini/ini.js
var require_ini = __commonJS((exports2) => {
  exports2.parse = exports2.decode = decode;
  exports2.stringify = exports2.encode = encode;
  exports2.safe = safe;
  exports2.unsafe = unsafe;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  function encode(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      if (val && Array.isArray(val)) {
        val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + "\n";
        });
      } else if (val && typeof val === "object")
        children.push(k);
      else
        out += safe(k) + separator + safe(val) + eol;
    });
    if (opt.section && out.length)
      out = "[" + safe(opt.section) + "]" + eol + out;
    children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\.");
      var section = (opt.section ? opt.section + "." : "") + nk;
      var child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      if (out.length && child.length)
        out += eol;
      out += child;
    });
    return out;
  }
  function dotSplit(str2) {
    return str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str2) {
    var out = {};
    var p = out;
    var section = null;
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str2.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
      if (!line || line.match(/^\s*[;#]/))
        return;
      var match = line.match(re);
      if (!match)
        return;
      if (match[1] !== void 0) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = {};
          return;
        }
        p = out[section] = out[section] || {};
        return;
      }
      var key = unsafe(match[2]);
      if (key === "__proto__")
        return;
      var value = match[3] ? unsafe(match[4]) : true;
      switch (value) {
        case "true":
        case "false":
        case "null":
          value = JSON.parse(value);
      }
      if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2);
        if (key === "__proto__")
          return;
        if (!p[key])
          p[key] = [];
        else if (!Array.isArray(p[key]))
          p[key] = [p[key]];
      }
      if (Array.isArray(p[key]))
        p[key].push(value);
      else
        p[key] = value;
    });
    Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
        return false;
      var parts = dotSplit(k);
      var p2 = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, ".");
      parts.forEach(function(part, _2, __2) {
        if (part === "__proto__")
          return;
        if (!p2[part] || typeof p2[part] !== "object")
          p2[part] = {};
        p2 = p2[part];
      });
      if (p2 === out && nl === l)
        return false;
      p2[nl] = out[k];
      return true;
    }).forEach(function(del, _, __) {
      delete out[del];
    });
    return out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'")
        val = val.substr(1, val.length - 2);
      try {
        val = JSON.parse(val);
      } catch (_) {
      }
    } else {
      var esc = false;
      var unesc = "";
      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1)
            unesc += c;
          else
            unesc += "\\" + c;
          esc = false;
        } else if (";#".indexOf(c) !== -1)
          break;
        else if (c === "\\")
          esc = true;
        else
          unesc += c;
      }
      if (esc)
        unesc += "\\";
      return unesc.trim();
    }
    return val;
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS((exports2, module2) => {
  "use strict";
  var singleComment = 1;
  var multiComment = 2;
  function stripWithoutWhitespace() {
    return "";
  }
  function stripWithWhitespace(str2, start, end) {
    return str2.slice(start, end).replace(/\S/g, " ");
  }
  module2.exports = function(str2, opts) {
    opts = opts || {};
    var currentChar;
    var nextChar;
    var insideString = false;
    var insideComment = false;
    var offset = 0;
    var ret = "";
    var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
    for (var i = 0; i < str2.length; i++) {
      currentChar = str2[i];
      nextChar = str2[i + 1];
      if (!insideComment && currentChar === '"') {
        var escaped = str2[i - 1] === "\\" && str2[i - 2] !== "\\";
        if (!escaped) {
          insideString = !insideString;
        }
      }
      if (insideString) {
        continue;
      }
      if (!insideComment && currentChar + nextChar === "//") {
        ret += str2.slice(offset, i);
        offset = i;
        insideComment = singleComment;
        i++;
      } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
        i++;
        insideComment = false;
        ret += strip(str2, offset, i);
        offset = i;
        continue;
      } else if (insideComment === singleComment && currentChar === "\n") {
        insideComment = false;
        ret += strip(str2, offset, i);
        offset = i;
      } else if (!insideComment && currentChar + nextChar === "/*") {
        ret += str2.slice(offset, i);
        offset = i;
        insideComment = multiComment;
        i++;
        continue;
      } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
        i++;
        insideComment = false;
        ret += strip(str2, offset, i + 1);
        offset = i + 1;
        continue;
      }
    }
    return ret + (insideComment ? strip(str2.substr(offset)) : str2.substr(offset));
  };
});

// node_modules/rc/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  var fs5 = require("fs");
  var ini = require_ini();
  var path5 = require("path");
  var stripJsonComments = require_strip_json_comments();
  var parse = exports2.parse = function(content) {
    if (/^\s*{/.test(content))
      return JSON.parse(stripJsonComments(content));
    return ini.parse(content);
  };
  var file = exports2.file = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    });
    for (var i in args)
      if (typeof args[i] !== "string")
        return;
    var file2 = path5.join.apply(null, args);
    var content;
    try {
      return fs5.readFileSync(file2, "utf-8");
    } catch (err) {
      return;
    }
  };
  var json2 = exports2.json = function() {
    var content = file.apply(null, arguments);
    return content ? parse(content) : null;
  };
  var env = exports2.env = function(prefix, env2) {
    env2 = env2 || process.env;
    var obj = {};
    var l = prefix.length;
    for (var k in env2) {
      if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        var keypath = k.substring(l).split("__");
        var _emptyStringIndex;
        while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
          keypath.splice(_emptyStringIndex, 1);
        }
        var cursor = obj;
        keypath.forEach(function _buildSubObj(_subkey, i) {
          if (!_subkey || typeof cursor !== "object")
            return;
          if (i === keypath.length - 1)
            cursor[_subkey] = env2[k];
          if (cursor[_subkey] === void 0)
            cursor[_subkey] = {};
          cursor = cursor[_subkey];
        });
      }
    }
    return obj;
  };
  var find = exports2.find = function() {
    var rel = path5.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file2 = path5.join(start, rel2);
      try {
        fs5.statSync(file2);
        return file2;
      } catch (err) {
        if (path5.dirname(start) !== start)
          return find2(path5.dirname(start), rel2);
      }
    }
    return find2(process.cwd(), rel);
  };
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS((exports2, module2) => {
  /*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  "use strict";
  function isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
  }
  function cloneSpecificValue(val) {
    if (val instanceof Buffer) {
      var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
      val.copy(x);
      return x;
    } else if (val instanceof Date) {
      return new Date(val.getTime());
    } else if (val instanceof RegExp) {
      return new RegExp(val);
    } else {
      throw new Error("Unexpected situation");
    }
  }
  function deepCloneArray(arr) {
    var clone = [];
    arr.forEach(function(item, index) {
      if (typeof item === "object" && item !== null) {
        if (Array.isArray(item)) {
          clone[index] = deepCloneArray(item);
        } else if (isSpecificValue(item)) {
          clone[index] = cloneSpecificValue(item);
        } else {
          clone[index] = deepExtend({}, item);
        }
      } else {
        clone[index] = item;
      }
    });
    return clone;
  }
  function safeGetProperty(object, property) {
    return property === "__proto__" ? void 0 : object[property];
  }
  var deepExtend = module2.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] !== "object") {
      return false;
    }
    if (arguments.length < 2) {
      return arguments[0];
    }
    var target = arguments[0];
    var args = Array.prototype.slice.call(arguments, 1);
    var val, src, clone;
    args.forEach(function(obj) {
      if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return;
      }
      Object.keys(obj).forEach(function(key) {
        src = safeGetProperty(target, key);
        val = safeGetProperty(obj, key);
        if (val === target) {
          return;
        } else if (typeof val !== "object" || val === null) {
          target[key] = val;
          return;
        } else if (Array.isArray(val)) {
          target[key] = deepCloneArray(val);
          return;
        } else if (isSpecificValue(val)) {
          target[key] = cloneSpecificValue(val);
          return;
        } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
          target[key] = deepExtend({}, val);
          return;
        } else {
          target[key] = deepExtend(src, val);
          return;
        }
      });
    });
    return target;
  };
});

// node_modules/minimist/index.js
var require_minimist = __commonJS((exports2, module2) => {
  module2.exports = function(args, opts) {
    if (!opts)
      opts = {};
    var flags = {bools: {}, strings: {}, unknownFn: null};
    if (typeof opts["unknown"] === "function") {
      flags.unknownFn = opts["unknown"];
    }
    if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
      flags.allBools = true;
    } else {
      [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = true;
      });
    }
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function(key2) {
      aliases[key2] = [].concat(opts.alias[key2]);
      aliases[key2].forEach(function(x) {
        aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
          return x !== y;
        }));
      });
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key2) {
      flags.strings[key2] = true;
      if (aliases[key2]) {
        flags.strings[aliases[key2]] = true;
      }
    });
    var defaults = opts["default"] || {};
    var argv = {_: []};
    Object.keys(flags.bools).forEach(function(key2) {
      setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
    });
    var notFlags = [];
    if (args.indexOf("--") !== -1) {
      notFlags = args.slice(args.indexOf("--") + 1);
      args = args.slice(0, args.indexOf("--"));
    }
    function argDefined(key2, arg2) {
      return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
    }
    function setArg(key2, val, arg2) {
      if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
        if (flags.unknownFn(arg2) === false)
          return;
      }
      var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
      setKey(argv, key2.split("."), value2);
      (aliases[key2] || []).forEach(function(x) {
        setKey(argv, x.split("."), value2);
      });
    }
    function setKey(obj, keys, value2) {
      var o = obj;
      for (var i2 = 0; i2 < keys.length - 1; i2++) {
        var key2 = keys[i2];
        if (key2 === "__proto__")
          return;
        if (o[key2] === void 0)
          o[key2] = {};
        if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
          o[key2] = {};
        if (o[key2] === Array.prototype)
          o[key2] = [];
        o = o[key2];
      }
      var key2 = keys[keys.length - 1];
      if (key2 === "__proto__")
        return;
      if (o === Object.prototype || o === Number.prototype || o === String.prototype)
        o = {};
      if (o === Array.prototype)
        o = [];
      if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
        o[key2] = value2;
      } else if (Array.isArray(o[key2])) {
        o[key2].push(value2);
      } else {
        o[key2] = [o[key2], value2];
      }
    }
    function aliasIsBoolean(key2) {
      return aliases[key2].some(function(x) {
        return flags.bools[x];
      });
    }
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        var key = m[1];
        var value = m[2];
        if (flags.bools[key]) {
          value = value !== "false";
        }
        setArg(key, value, arg);
      } else if (/^--no-.+/.test(arg)) {
        var key = arg.match(/^--no-(.+)/)[1];
        setArg(key, false, arg);
      } else if (/^--.+/.test(arg)) {
        var key = arg.match(/^--(.+)/)[1];
        var next = args[i + 1];
        if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, next, arg);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next === "true", arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? "" : true, arg);
        }
      } else if (/^-[^-]+/.test(arg)) {
        var letters = arg.slice(1, -1).split("");
        var broken = false;
        for (var j = 0; j < letters.length; j++) {
          var next = arg.slice(j + 2);
          if (next === "-") {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
            setArg(letters[j], next.split("=")[1], arg);
            broken = true;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg);
            broken = true;
            break;
          } else {
            setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
          }
        }
        var key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, args[i + 1], arg);
            i++;
          } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
            setArg(key, args[i + 1] === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        }
      } else {
        if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
          argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
        }
        if (opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
    }
    Object.keys(defaults).forEach(function(key2) {
      if (!hasKey(argv, key2.split("."))) {
        setKey(argv, key2.split("."), defaults[key2]);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), defaults[key2]);
        });
      }
    });
    if (opts["--"]) {
      argv["--"] = new Array();
      notFlags.forEach(function(key2) {
        argv["--"].push(key2);
      });
    } else {
      notFlags.forEach(function(key2) {
        argv._.push(key2);
      });
    }
    return argv;
  };
  function hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key2) {
      o = o[key2] || {};
    });
    var key = keys[keys.length - 1];
    return key in o;
  }
  function isNumber(x) {
    if (typeof x === "number")
      return true;
    if (/^0x[0-9a-f]+$/i.test(x))
      return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS((exports2, module2) => {
  var cc = require_utils2();
  var join = require("path").join;
  var deepExtend = require_deep_extend();
  var etc = "/etc";
  var win = process.platform === "win32";
  var home = win ? process.env.USERPROFILE : process.env.HOME;
  module2.exports = function(name, defaults, argv, parse) {
    if (typeof name !== "string")
      throw new Error("rc(name): name *must* be string");
    if (!argv)
      argv = require_minimist()(process.argv.slice(2));
    defaults = (typeof defaults === "string" ? cc.json(defaults) : defaults) || {};
    parse = parse || cc.parse;
    var env = cc.env(name + "_");
    var configs = [defaults];
    var configFiles = [];
    function addConfigFile(file) {
      if (configFiles.indexOf(file) >= 0)
        return;
      var fileConfig = cc.file(file);
      if (fileConfig) {
        configs.push(parse(fileConfig));
        configFiles.push(file);
      }
    }
    if (!win)
      [
        join(etc, name, "config"),
        join(etc, name + "rc")
      ].forEach(addConfigFile);
    if (home)
      [
        join(home, ".config", name, "config"),
        join(home, ".config", name),
        join(home, "." + name, "config"),
        join(home, "." + name + "rc")
      ].forEach(addConfigFile);
    addConfigFile(cc.find("." + name + "rc"));
    if (env.config)
      addConfigFile(env.config);
    if (argv.config)
      addConfigFile(argv.config);
    return deepExtend.apply(null, configs.concat([
      env,
      argv,
      configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : void 0
    ]));
  };
});

// node_modules/requireg/lib/resolvers.js
var require_resolvers = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var path5 = require("path");
  var resolve = require_resolve().sync;
  var rc = require_rc();
  var spawnSync = require("child_process").spawnSync;
  var isWin32 = process.platform === "win32";
  module2.exports = [
    nativeResolve,
    nodePathResolve,
    userHomeResolve,
    nodeModulesResolve,
    yarnModulesResolve,
    prefixResolve,
    execPathResolve
  ];
  function resolveFn(module3, basePath, dirname) {
    try {
      return resolve(module3, {
        basedir: path5.join(basePath, dirname || "")
      });
    } catch (e) {
    }
  }
  function nativeResolve(module3, dirname) {
    try {
      return require.resolve(module3, dirname);
    } catch (e) {
    }
  }
  function nodePathResolve(module3, dirname) {
    var i, l, modulePath;
    var nodePath = process.env.NODE_PATH;
    if (!nodePath) {
      return;
    }
    nodePath = nodePath.split(path5.delimiter).map(function(nodepath) {
      return path5.normalize(nodepath);
    });
    for (i = 0, l = nodePath.length; i < l; i += 1) {
      if (modulePath = resolveFn(module3, dirname || nodePath[i])) {
        break;
      }
    }
    return modulePath;
  }
  function userHomeResolve(module3) {
    var i, l, modulePath;
    var homePath = isWin32 ? process.env["USERPROFILE"] : process.env["HOME"];
    var paths = [
      "node_modules",
      "node_libraries",
      "node_packages"
    ];
    for (i = 0, l = paths.length; i < l; i += 1) {
      if (modulePath = resolveFn(module3, homePath, paths[i])) {
        break;
      }
    }
    return modulePath;
  }
  function prefixResolve(module3) {
    var modulePath, dirname;
    var prefix = rc("npm").prefix;
    if (isWin32) {
      prefix = prefix || path5.join(process.env.APPDATA, "npm");
      dirname = prefix;
    } else {
      prefix = prefix || path5.join(path5.dirname(process.execPath), "..");
      dirname = path5.join(prefix, "lib");
    }
    dirname = path5.join(dirname, "node_modules");
    modulePath = resolveFn(module3, dirname);
    return modulePath;
  }
  function execPathResolve(module3) {
    var modulePath, dirname;
    var execPath = path5.dirname(process.execPath);
    if (isWin32) {
      dirname = execPath;
    } else {
      dirname = path5.join(execPath, "..", "lib");
    }
    dirname = path5.join(dirname, "node_modules");
    modulePath = resolveFn(module3, dirname);
    return modulePath;
  }
  function nodeModulesResolve(module3) {
    var i, l, modulePath;
    var nodeModules = process.env["NODE_MODULES"];
    if (typeof nodeModules === "string") {
      nodeModules = nodeModules.split(path5.delimiter);
      for (i = 0, l = nodeModules.length; i < l; i += 1) {
        if (modulePath = resolveFn(module3, nodeModules[i])) {
          break;
        }
      }
    }
    return modulePath;
  }
  function yarnModulesResolve(module3) {
    var i, modulePath;
    var yarnCmd = isWin32 ? "yarn.cmd" : "yarn";
    var result = spawnSync(yarnCmd, ["global", "dir"], {encoding: "utf8"});
    if (!result.error && result.stdout) {
      var yarnPath = result.stdout.replace(/[\r\n]+/g, "");
      var nodeModulesStr = path5.join(yarnPath, "node_modules");
      if (typeof nodeModulesStr === "string") {
        var nodeModules = nodeModulesStr.split(path5.delimiter);
        for (i = 0; i < nodeModules.length; i++) {
          if (modulePath = resolveFn(module3, nodeModules[i])) {
            break;
          }
        }
      }
    }
    return modulePath;
  }
});

// node_modules/nested-error-stacks/index.js
var require_nested_error_stacks = __commonJS((exports2, module2) => {
  var inherits = require("util").inherits;
  var NestedError = function(message, nested) {
    this.nested = nested;
    if (typeof message !== "undefined") {
      Object.defineProperty(this, "message", {
        value: message,
        writable: true,
        enumerable: false,
        configurable: true
      });
    }
    Error.captureStackTrace(this, this.constructor);
    var oldStackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
    var stackDescriptor = buildStackDescriptor(oldStackDescriptor, nested);
    Object.defineProperty(this, "stack", stackDescriptor);
  };
  function buildStackDescriptor(oldStackDescriptor, nested) {
    if (oldStackDescriptor.get) {
      return {
        get: function() {
          var stack2 = oldStackDescriptor.get.call(this);
          return buildCombinedStacks(stack2, this.nested);
        }
      };
    } else {
      var stack = oldStackDescriptor.value;
      return {
        value: buildCombinedStacks(stack, nested)
      };
    }
  }
  function buildCombinedStacks(stack, nested) {
    if (nested) {
      stack += "\nCaused By: " + nested.stack;
    }
    return stack;
  }
  inherits(NestedError, Error);
  NestedError.prototype.name = "NestedError";
  module2.exports = NestedError;
});

// node_modules/requireg/lib/requireg.js
var require_requireg = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var path5 = require("path");
  var resolvers = require_resolvers();
  var NestedError = require_nested_error_stacks();
  module2.exports = requireg;
  function requireg(module3, onlyGlobal) {
    try {
      return require(resolve(module3, void 0, onlyGlobal));
    } catch (e) {
      throw new NestedError("Could not require module '" + module3 + "'", e);
    }
  }
  requireg.resolve = resolve;
  requireg.globalize = function() {
    global.requireg = requireg;
  };
  function resolve(module3, dirname, onlyGlobal) {
    var i, l, resolver, modulePath;
    for (i = onlyGlobal ? 1 : 0, l = resolvers.length; i < l; i += 1) {
      resolver = resolvers[i];
      if (modulePath = resolver(module3, dirname)) {
        break;
      }
    }
    return modulePath;
  }
});

// node_modules/unibeautify/dist/src/DependencyManager/NodeDependency.js
var require_NodeDependency = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Dependency_1 = require_Dependency();
  var NodeDependency = class extends Dependency_1.Dependency {
    constructor(definition, options = {}) {
      super(definition, options);
      this.definition = definition;
    }
    loadVersion() {
      try {
        return Promise.resolve(this.require("package.json").version);
      } catch (error) {
        return Promise.reject(error);
      }
    }
    get package() {
      return this.require();
    }
    require(id) {
      const path5 = this.fullPath(id);
      const modulePath = this.resolve(path5);
      if (modulePath) {
        return require(modulePath);
      } else {
        throw new Error(`Cannot find module ${path5}`);
      }
    }
    resolve(path5) {
      return this.resolveLocal(path5) || this.resolveGlobal(path5);
    }
    resolveLocal(path5) {
      return this.resolveWith(require.resolve)(path5);
    }
    resolveGlobal(path5) {
      const requireg = require_requireg();
      return this.resolveWith(requireg.resolve)(path5);
    }
    resolveWith(resolver) {
      return (path5) => {
        try {
          return resolver(path5);
        } catch (error) {
          return void 0;
        }
      };
    }
    fullPath(filePath) {
      if (filePath) {
        return `${this.packageName}/${filePath}`;
      }
      return this.packageName;
    }
    get packageName() {
      return this.definition.package;
    }
  };
  exports2.NodeDependency = NodeDependency;
});

// node_modules/unibeautify/dist/src/DependencyManager/ExecutableDependency.js
var require_ExecutableDependency = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Dependency_1 = require_Dependency();
  var ExecutableDependency = class extends Dependency_1.Dependency {
    constructor(definition, options = {}) {
      super(definition, options);
      this.definition = definition;
    }
    loadVersion() {
      return this.run({args: this.versionArgs}).then(({stdout, exitCode, stderr}) => {
        return stdout || stderr;
      });
    }
    get versionArgs() {
      return this.definition.versionArgs || ["--version"];
    }
    run({args, options = {}, stdin}) {
      return this.resolveArgs(args).then((finalArgs) => this.spawn({exe: this.pathOrProgram, args: finalArgs, options, stdin}));
    }
    resolveArgs(args) {
      return Promise.all(args).then((resolvedArgs) => resolvedArgs.filter(Boolean));
    }
    get pathOrProgram() {
      return this.programPath || this.program;
    }
    get program() {
      return this.definition.program;
    }
    get programPath() {
      return this.options.path;
    }
    spawn({exe, args, options, stdin}) {
      return new Promise((resolve, reject) => {
        const spawn = require("child_process").spawn;
        const cmd = spawn(exe, args, Object.assign({}, options, {env: Object.assign({}, process.env, options.env || {})}));
        let stdout = "";
        let stderr = "";
        cmd.stdout.on("data", (data) => {
          return stdout += data;
        });
        cmd.stderr.on("data", (data) => {
          return stderr += data;
        });
        cmd.on("close", (exitCode) => {
          return resolve({exitCode, stdout, stderr});
        });
        cmd.on("error", (err) => {
          return reject(err);
        });
        if (stdin) {
          cmd.stdin.end(stdin);
        }
      });
    }
  };
  exports2.ExecutableDependency = ExecutableDependency;
});

// node_modules/unibeautify/dist/src/DependencyManager/DependencyFactory.js
var require_DependencyFactory = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Dependency_1 = require_Dependency();
  var NodeDependency_1 = require_NodeDependency();
  var ExecutableDependency_1 = require_ExecutableDependency();
  var DependencyFactory = class {
    constructor(definition, options) {
      this.definition = definition;
      this.options = options;
    }
    dependency() {
      const {definition, options} = this;
      switch (definition.type) {
        case Dependency_1.DependencyType.Node:
          return new NodeDependency_1.NodeDependency(definition, options);
        case Dependency_1.DependencyType.Executable:
          return new ExecutableDependency_1.ExecutableDependency(definition, options);
        default:
          throw new Error(`Dependency type not found for: ${JSON.stringify(definition)}`);
      }
    }
  };
  exports2.DependencyFactory = DependencyFactory;
});

// node_modules/unibeautify/dist/src/DependencyManager/DependencyManager.js
var require_DependencyManager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var DependencyFactory_1 = require_DependencyFactory();
  var DependencyManager = class {
    constructor(beautifierName, dependencyDefinitions = [], options = {}) {
      this.beautifierName = beautifierName;
      this.dependencyDefinitions = dependencyDefinitions;
      this.options = options;
      this.initializeDependencies();
    }
    static clearRegistry() {
      this.registry = {};
    }
    load() {
      return Promise.all(this.dependencyDefinitions.map((def) => this.get(def.name)).map((dep) => dep.load())).then(() => true);
    }
    initializeDependencies() {
      const lookup = DependencyManager.registry;
      const beautifierLookup = lookup[this.beautifierName] || {};
      lookup[this.beautifierName] = beautifierLookup;
      this.dependencyDefinitions.forEach((def) => {
        const {name: dependencyName} = def;
        const options = this.optionsForDependency(dependencyName);
        const optionsKey = this.keyForOptions(options);
        const depLookup = beautifierLookup[dependencyName] || {};
        beautifierLookup[dependencyName] = depLookup;
        depLookup[optionsKey] = depLookup[optionsKey] || this.createDependency(def, options);
      });
    }
    has(name) {
      return Boolean(this.get(name));
    }
    get(dependencyName) {
      const options = this.optionsForDependency(dependencyName);
      const optionsKey = this.keyForOptions(options);
      const lookup = this.registry[dependencyName] || {};
      const dep = lookup[optionsKey];
      if (!dep) {
        throw new Error(`Dependency with name ${dependencyName} not found.`);
      }
      return dep;
    }
    optionsForDependency(dependencyName) {
      return this.options[dependencyName];
    }
    get registry() {
      return DependencyManager.registry[this.beautifierName];
    }
    createDependency(definition, options) {
      return new DependencyFactory_1.DependencyFactory(definition, options).dependency();
    }
    keyForOptions(options = {}) {
      return JSON.stringify(options);
    }
  };
  DependencyManager.registry = {};
  exports2.DependencyManager = DependencyManager;
});

// node_modules/unibeautify/dist/src/DependencyManager/index.js
var require_DependencyManager2 = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  __export2(require_Dependency());
  __export2(require_DependencyManager());
  __export2(require_DependencyFactory());
  __export2(require_NodeDependency());
  __export2(require_ExecutableDependency());
  __export2(require_Version());
});

// node_modules/unibeautify/dist/src/beautifier.js
var require_beautifier = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var LanguageManager_1 = require_LanguageManager();
  var OptionsManager_1 = require_OptionsManager();
  var InlineFlagManager_1 = require_InlineFlagManager();
  var DependencyManager_1 = require_DependencyManager2();
  var utils_1 = require_utils();
  var Unibeautify = class {
    constructor() {
      this.options = {};
      this.languages = [];
      this.beautifiers = [];
      this.languageManager = new LanguageManager_1.LanguageManager(this.languages);
      this.optionsManager = new OptionsManager_1.OptionsManager(this.options);
    }
    getLanguagesSupportingOption(optionName) {
      return this.supportedLanguages.filter((language) => this.beautifiers.findIndex((beautifier) => this.doesBeautifierSupportOptionForLanguage({
        beautifier,
        language,
        optionName
      })) !== -1);
    }
    getOptionsSupportedForLanguage(language) {
      return this.beautifiers.reduce((options, beautifier) => Object.assign({}, options, this.getOptionsSupportedByBeautifierForLanguage({
        beautifier,
        language
      })), {});
    }
    getOptionsSupportedByBeautifierForLanguage({beautifier, language}) {
      const keys = OptionsManager_1.optionKeys(beautifier, language);
      const allOptions = this.optionsManager.options;
      return keys.reduce((options, key) => {
        const option = allOptions[key];
        if (!option) {
          return options;
        }
        return Object.assign({}, options, {[key]: option});
      }, {});
    }
    get supportedLanguages() {
      return this.getLoadedLanguages().filter((language) => Boolean(this.getBeautifierForLanguage(language)));
    }
    beautify(data) {
      const lang = this.languageManager.getLanguage(data);
      if (lang == null) {
        return Promise.reject(new Error("Cannot find language."));
      }
      const langOptions = Unibeautify.getOptionsForLanguage(lang, data.options);
      const {selectedBeautifiers, missingBeautifierName} = this.beautifiersForLanguageAndOptions(lang, langOptions);
      if (selectedBeautifiers.length === 0) {
        return Promise.reject(new Error(`Beautifiers not found for Language: ${lang.name}`));
      }
      if (missingBeautifierName) {
        return Promise.reject(new Error(`Beautifier not found: ${missingBeautifierName}`));
      }
      return this.beautifyWithBeautifiers({
        beautifiers: selectedBeautifiers,
        fileExtension: data.fileExtension,
        filePath: data.filePath,
        langOptions,
        language: lang,
        projectPath: data.projectPath,
        text: data.text
      });
    }
    beautifiersForLanguageAndOptions(lang, langOptions) {
      const allBeautifiers = this.getBeautifiersForLanguage(lang);
      const beautifierNames = langOptions.beautifiers || [];
      const selectedBeautifiers = beautifierNames.length > 0 ? this.beautifiersWithNames(beautifierNames, allBeautifiers) : allBeautifiers;
      const missingBeautifierName = selectedBeautifiers.map((curr, index) => curr ? void 0 : beautifierNames[index]).find((curr) => !!curr);
      return {
        missingBeautifierName,
        selectedBeautifiers
      };
    }
    beautifiersWithNames(names, beautifiers2) {
      const beautifiersByName = beautifiers2.reduce((index, current) => {
        index[current.name] = current;
        return index;
      }, {});
      return names.map((name) => beautifiersByName[name]);
    }
    beautifyWithBeautifiers({beautifiers: beautifiers2, language, langOptions, fileExtension, filePath, projectPath, text}) {
      return beautifiers2.reduce((promise, beautifier) => {
        const options = Unibeautify.getOptionsForBeautifier(beautifier, language, langOptions);
        return promise.then((currentText) => {
          const beautifierOptions = langOptions[beautifier.name] || {};
          const dependencyManager = new DependencyManager_1.DependencyManager(beautifier.name, beautifier.dependencies || [], beautifierOptions);
          return dependencyManager.load().then(() => {
            if (beautifierOptions.prefer_beautifier_config && beautifier.resolveConfig) {
              const resolveConfigPath = typeof beautifierOptions.prefer_beautifier_config === "string" ? beautifierOptions.prefer_beautifier_config : filePath;
              return beautifier.resolveConfig({
                dependencies: dependencyManager,
                filePath: resolveConfigPath,
                projectPath
              });
            }
            return Promise.resolve({});
          }).then((beautifierConfig) => {
            return beautifier.beautify({
              beautifierConfig,
              dependencies: dependencyManager,
              filePath,
              language,
              options,
              projectPath,
              text: currentText
            }).then((newText) => {
              if (typeof newText !== "string") {
                return Promise.reject(new Error(`Beautifier response type must be "string" not "${typeof newText}": ${newText}`));
              }
              return Promise.resolve(newText);
            }).then((newText) => this.handleInlineFlags(currentText, newText));
          });
        });
      }, Promise.resolve(text));
    }
    handleInlineFlags(currentText, newText) {
      const manager = new InlineFlagManager_1.InlineFlagManager(currentText, newText);
      return manager.text;
    }
    findLanguages(query) {
      return this.languageManager.findLanguages(query);
    }
    getLoadedLanguages() {
      return this.languageManager.getLoadedLanguages();
    }
    getBeautifierForLanguage(language) {
      return this.beautifiers.find((beautifier) => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    getBeautifiersForLanguage(language) {
      return this.beautifiers.filter((beautifier) => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    doesBeautifierSupportLanguage(beautifier, language) {
      return beautifier.options.hasOwnProperty(language.name);
    }
    getBeautifiersSupportingOption(optionName) {
      return this.beautifiers.filter((beautifier) => this.languageManager.languages.findIndex((language) => this.doesBeautifierSupportOptionForLanguage({
        beautifier,
        language,
        optionName
      })) !== -1);
    }
    doesBeautifierSupportOptionForLanguage({beautifier, language, optionName}) {
      return OptionsManager_1.optionKeys(beautifier, language).indexOf(optionName) !== -1;
    }
    getLanguagesForBeautifier(beautifier) {
      const {options} = beautifier;
      return this.languageManager.languages.filter((lang) => options.hasOwnProperty(lang.name));
    }
    get loadedOptions() {
      return this.optionsManager.loadedOptions;
    }
    get loadedBeautifiers() {
      return this.beautifiers.slice();
    }
    static getOptionsForLanguage(language, options) {
      const {name} = language;
      return options[name] || {};
    }
    static getOptionsForBeautifier(beautifier, language, options) {
      const beautifierOptions = beautifier.options[language.name];
      if (typeof beautifierOptions === "boolean" && beautifierOptions === false) {
        return {};
      } else if (typeof beautifierOptions === "object") {
        return Object.keys(beautifierOptions).reduce((acc, key) => {
          const option = beautifierOptions[key];
          if (typeof option === "string") {
            return Object.assign({}, acc, {[key]: options[option]});
          } else if (typeof option === "function") {
            return Object.assign({}, acc, {[key]: option(options[key])});
          } else if (option === true) {
            return Object.assign({}, acc, {[key]: options[key]});
          } else if (option instanceof Array) {
            const [fields, fn] = option;
            const values = fields.map((field) => options[field]);
            const obj = utils_1.zipObject(fields, values);
            return Object.assign({}, acc, {[key]: fn(obj)});
          }
          console.log(`Invalid option "${key}" with value ${JSON.stringify(option)}.`);
          return acc;
        }, {});
      } else {
        return options;
      }
    }
    loadBeautifier(beautifier) {
      this.validateBeautifier(beautifier);
      this.beautifiers.push(beautifier);
      return this;
    }
    validateBeautifier(beautifier = {}) {
      if (!beautifier.name) {
        throw new Error('Beautifier is missing a "name" property.');
      }
      new DependencyManager_1.DependencyManager(beautifier.name, beautifier.dependencies, {});
    }
    loadBeautifiers(beautifiers2) {
      beautifiers2.forEach((beautifier) => this.loadBeautifier(beautifier));
      return this;
    }
    loadLanguage(language) {
      this.languageManager.loadLanguage(language);
      return this;
    }
    loadLanguages(languages2) {
      this.languageManager.loadLanguages(languages2);
      return this;
    }
    loadOptions(options) {
      this.optionsManager.loadOptions(options);
      return this;
    }
  };
  exports2.Unibeautify = Unibeautify;
});

// node_modules/unibeautify/dist/src/languages.json
var require_languages = __commonJS((exports2, module2) => {
  module2.exports = [
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bsl",
        ".os"
      ],
      fileNames: [],
      liguistLanguageId: 0,
      name: "1C Enterprise",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.bsl",
      vscodeLanguages: []
    },
    {
      aceMode: "abap",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".abap"
      ],
      fileNames: [],
      liguistLanguageId: 1,
      name: "ABAP",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "abap"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".abnf"
      ],
      fileNames: [],
      liguistLanguageId: 429,
      name: "ABNF",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.abnf",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".asc",
        ".ash"
      ],
      fileNames: [],
      liguistLanguageId: 2,
      name: "AGS Script",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c++",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ampl",
        ".mod"
      ],
      fileNames: [],
      liguistLanguageId: 3,
      name: "AMPL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ampl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".g4"
      ],
      fileNames: [],
      liguistLanguageId: 4,
      name: "ANTLR",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "markdown",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".apib"
      ],
      fileNames: [],
      liguistLanguageId: 5,
      name: "API Blueprint",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.markdown.source.gfm.apib",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/apl",
      codeMirrorMode: "apl",
      extensions: [
        ".apl",
        ".dyalog"
      ],
      fileNames: [],
      liguistLanguageId: 6,
      name: "APL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.apl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ttcn-asn",
      codeMirrorMode: "asn.1",
      extensions: [
        ".asn",
        ".asn1"
      ],
      fileNames: [],
      liguistLanguageId: 7,
      name: "ASN.1",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.asn",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-aspx",
      codeMirrorMode: "htmlembedded",
      extensions: [
        ".asax",
        ".ascx",
        ".ashx",
        ".asmx",
        ".asp",
        ".aspx",
        ".axd"
      ],
      fileNames: [],
      liguistLanguageId: 8,
      name: "ASP",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.asp",
      vscodeLanguages: []
    },
    {
      aceMode: "ocaml",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".dats",
        ".hats",
        ".sats"
      ],
      fileNames: [],
      liguistLanguageId: 9,
      name: "ATS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ats",
      vscodeLanguages: []
    },
    {
      aceMode: "actionscript",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".as"
      ],
      fileNames: [],
      liguistLanguageId: 10,
      name: "ActionScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.actionscript.3",
      vscodeLanguages: []
    },
    {
      aceMode: "ada",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ada",
        ".adb",
        ".ads"
      ],
      fileNames: [],
      liguistLanguageId: 11,
      name: "Ada",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".afm"
      ],
      fileNames: [],
      liguistLanguageId: 147198098,
      name: "Adobe Font Metrics",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.afm",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".agda"
      ],
      fileNames: [],
      liguistLanguageId: 12,
      name: "Agda",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".als"
      ],
      fileNames: [],
      liguistLanguageId: 13,
      name: "Alloy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [],
      fileNames: [
        "APKBUILD"
      ],
      group: "Shell",
      liguistLanguageId: 14,
      name: "Alpine Abuild",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shell",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".angelscript",
        ".as"
      ],
      fileNames: [],
      liguistLanguageId: 389477596,
      name: "AngelScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.angelscript",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/xml",
      codeMirrorMode: "xml",
      extensions: [],
      fileNames: [
        "ant.xml",
        "build.xml"
      ],
      liguistLanguageId: 15,
      name: "Ant Build System",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml.ant",
      vscodeLanguages: []
    },
    {
      aceMode: "apache_conf",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".apacheconf",
        ".vhost"
      ],
      fileNames: [],
      liguistLanguageId: 16,
      name: "ApacheConf",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.apache-config",
      vscodeLanguages: []
    },
    {
      aceMode: "java",
      aliases: [],
      atomGrammars: [
        "Apex"
      ],
      codeMirrorMimeType: "text/x-java",
      codeMirrorMode: "clike",
      extensions: [
        ".cls",
        ".trigger"
      ],
      fileNames: [],
      liguistLanguageId: 17,
      name: "Apex",
      namespace: "apex",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.java",
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".agc"
      ],
      fileNames: [],
      group: "Assembly",
      liguistLanguageId: 18,
      name: "Apollo Guidance Computer",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.agc",
      vscodeLanguages: []
    },
    {
      aceMode: "applescript",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".applescript",
        ".scpt"
      ],
      fileNames: [],
      liguistLanguageId: 19,
      name: "AppleScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".arc"
      ],
      fileNames: [],
      liguistLanguageId: 20,
      name: "Arc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [
        "Arduino"
      ],
      extensions: [
        ".ino",
        ".pde"
      ],
      fileNames: [],
      liguistLanguageId: 21,
      name: "Arduino",
      namespace: "arduino",
      sublimeSyntaxes: [],
      textMateScope: "source.c++",
      vscodeLanguages: []
    },
    {
      aceMode: "asciidoc",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".adoc",
        ".asc",
        ".asciidoc"
      ],
      fileNames: [],
      liguistLanguageId: 22,
      name: "AsciiDoc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.asciidoc",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".aj"
      ],
      fileNames: [],
      liguistLanguageId: 23,
      name: "AspectJ",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.aspectj",
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".a51",
        ".asm",
        ".inc",
        ".nasm"
      ],
      fileNames: [],
      liguistLanguageId: 24,
      name: "Assembly",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.assembly",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".aug"
      ],
      fileNames: [],
      liguistLanguageId: 25,
      name: "Augeas",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "autohotkey",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ahk",
        ".ahkl"
      ],
      fileNames: [],
      liguistLanguageId: 26,
      name: "AutoHotkey",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ahk",
      vscodeLanguages: []
    },
    {
      aceMode: "autohotkey",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".au3"
      ],
      fileNames: [],
      liguistLanguageId: 27,
      name: "AutoIt",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.autoit",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".auk",
        ".awk",
        ".gawk",
        ".mawk",
        ".nawk"
      ],
      fileNames: [],
      liguistLanguageId: 28,
      name: "Awk",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bal"
      ],
      fileNames: [],
      liguistLanguageId: 720859680,
      name: "Ballerina",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ballerina",
      vscodeLanguages: []
    },
    {
      aceMode: "batchfile",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bat",
        ".cmd"
      ],
      fileNames: [],
      liguistLanguageId: 29,
      name: "Batchfile",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.batchfile",
      vscodeLanguages: [
        "bat"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".befunge"
      ],
      fileNames: [],
      liguistLanguageId: 30,
      name: "Befunge",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bison"
      ],
      fileNames: [],
      group: "Yacc",
      liguistLanguageId: 31,
      name: "Bison",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.bison",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bb"
      ],
      fileNames: [],
      liguistLanguageId: 32,
      name: "BitBake",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".blade",
        ".blade.php"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 33,
      name: "Blade",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.php.blade",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bb",
        ".decls"
      ],
      fileNames: [],
      liguistLanguageId: 34,
      name: "BlitzBasic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.blitzmax",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bmx"
      ],
      fileNames: [],
      liguistLanguageId: 35,
      name: "BlitzMax",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "verilog",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bsv"
      ],
      fileNames: [],
      liguistLanguageId: 36,
      name: "Bluespec",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.bsv",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".boo"
      ],
      fileNames: [],
      liguistLanguageId: 37,
      name: "Boo",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.boo",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-brainfuck",
      codeMirrorMode: "brainfuck",
      extensions: [
        ".b",
        ".bf"
      ],
      fileNames: [],
      liguistLanguageId: 38,
      name: "Brainfuck",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.bf",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".brs"
      ],
      fileNames: [],
      liguistLanguageId: 39,
      name: "Brightscript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.brightscript",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bro"
      ],
      fileNames: [],
      liguistLanguageId: 40,
      name: "Bro",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [
        "C",
        "opencl"
      ],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".c",
        ".cats",
        ".cl",
        ".h",
        ".idc"
      ],
      fileNames: [],
      liguistLanguageId: 41,
      name: "C",
      namespace: "c",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "c"
      ]
    },
    {
      aceMode: "csharp",
      aliases: [],
      atomGrammars: [
        "C#"
      ],
      codeMirrorMimeType: "text/x-csharp",
      codeMirrorMode: "clike",
      extensions: [
        ".cake",
        ".cs",
        ".cshtml",
        ".csx"
      ],
      fileNames: [],
      liguistLanguageId: 42,
      name: "C#",
      namespace: "cs",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cs",
      vscodeLanguages: [
        "csharp"
      ]
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [
        "C++"
      ],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".C",
        ".c++",
        ".cc",
        ".cp",
        ".cpp",
        ".cxx",
        ".h",
        ".h++",
        ".hh",
        ".hpp",
        ".hxx",
        ".inc",
        ".inl",
        ".ino",
        ".ipp",
        ".re",
        ".tcc",
        ".tpp"
      ],
      fileNames: [],
      liguistLanguageId: 43,
      name: "C++",
      namespace: "cpp",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "cpp"
      ]
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".c-objdump"
      ],
      fileNames: [],
      liguistLanguageId: 44,
      name: "C-ObjDump",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "objdump.x86asm",
      vscodeLanguages: []
    },
    {
      aceMode: "haskell",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-haskell",
      codeMirrorMode: "haskell",
      extensions: [
        ".chs"
      ],
      fileNames: [],
      group: "Haskell",
      liguistLanguageId: 45,
      name: "C2hs Haskell",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.haskell",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".clp"
      ],
      fileNames: [],
      liguistLanguageId: 46,
      name: "CLIPS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clips",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-cmake",
      codeMirrorMode: "cmake",
      extensions: [
        ".cmake",
        ".cmake.in"
      ],
      fileNames: [
        "CMakeLists.txt"
      ],
      liguistLanguageId: 47,
      name: "CMake",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "cobol",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-cobol",
      codeMirrorMode: "cobol",
      extensions: [
        ".cbl",
        ".ccp",
        ".cob",
        ".cobol",
        ".cpy"
      ],
      fileNames: [],
      liguistLanguageId: 48,
      name: "COBOL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".dae"
      ],
      fileNames: [],
      liguistLanguageId: 49,
      name: "COLLADA",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "coffee",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-coffeescript",
      codeMirrorMode: "coffeescript",
      extensions: [
        ".cson"
      ],
      fileNames: [],
      group: "CoffeeScript",
      liguistLanguageId: 424,
      name: "CSON",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.coffee",
      vscodeLanguages: []
    },
    {
      aceMode: "css",
      aliases: [],
      atomGrammars: [
        "CSS"
      ],
      codeMirrorMimeType: "text/css",
      codeMirrorMode: "css",
      extensions: [
        ".css"
      ],
      fileNames: [],
      liguistLanguageId: 50,
      name: "CSS",
      namespace: "css",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.css",
      vscodeLanguages: [
        "css"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "CSV"
      ],
      extensions: [
        ".csv"
      ],
      fileNames: [],
      liguistLanguageId: 51,
      name: "CSV",
      namespace: "csv",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".w"
      ],
      fileNames: [],
      liguistLanguageId: 657332628,
      name: "CWeb",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".capnp"
      ],
      fileNames: [],
      liguistLanguageId: 52,
      name: "Cap'n Proto",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.capnp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mss"
      ],
      fileNames: [],
      liguistLanguageId: 53,
      name: "CartoCSS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.css.mss",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ceylon"
      ],
      fileNames: [],
      liguistLanguageId: 54,
      name: "Ceylon",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ceylon",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".chpl"
      ],
      fileNames: [],
      liguistLanguageId: 55,
      name: "Chapel",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ch"
      ],
      fileNames: [],
      liguistLanguageId: 56,
      name: "Charity",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "java",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-java",
      codeMirrorMode: "clike",
      extensions: [
        ".ck"
      ],
      fileNames: [],
      liguistLanguageId: 57,
      name: "ChucK",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.java",
      vscodeLanguages: []
    },
    {
      aceMode: "cirru",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cirru"
      ],
      fileNames: [],
      liguistLanguageId: 58,
      name: "Cirru",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".clw"
      ],
      fileNames: [],
      liguistLanguageId: 59,
      name: "Clarion",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clarion",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".dcl",
        ".icl"
      ],
      fileNames: [],
      liguistLanguageId: 60,
      name: "Clean",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clean",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".click"
      ],
      fileNames: [],
      liguistLanguageId: 61,
      name: "Click",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.click",
      vscodeLanguages: []
    },
    {
      aceMode: "clojure",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-clojure",
      codeMirrorMode: "clojure",
      extensions: [
        ".boot",
        ".cl2",
        ".clj",
        ".cljc",
        ".cljs",
        ".cljs.hl",
        ".cljscm",
        ".cljx",
        ".hic"
      ],
      fileNames: [
        "riemann.config"
      ],
      liguistLanguageId: 62,
      name: "Clojure",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "clojure"
      ]
    },
    {
      aceMode: "soy_template",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-soy",
      codeMirrorMode: "soy",
      extensions: [
        ".soy"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 357046146,
      name: "Closure Templates",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.soy",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".conll",
        ".conllu"
      ],
      fileNames: [],
      liguistLanguageId: 421026389,
      name: "CoNLL-U",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.conllu",
      vscodeLanguages: []
    },
    {
      aceMode: "coffee",
      aliases: [],
      atomGrammars: [
        "CoffeeScript"
      ],
      codeMirrorMimeType: "text/x-coffeescript",
      codeMirrorMode: "coffeescript",
      extensions: [
        "._coffee",
        ".cake",
        ".cjsx",
        ".coffee",
        ".iced"
      ],
      fileNames: [
        "Cakefile"
      ],
      liguistLanguageId: 63,
      name: "CoffeeScript",
      namespace: "coffeescript",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.coffee",
      vscodeLanguages: [
        "coffeescript"
      ]
    },
    {
      aceMode: "coldfusion",
      aliases: [],
      atomGrammars: [
        "html"
      ],
      extensions: [
        ".cfc",
        ".cfm",
        ".cfml"
      ],
      fileNames: [],
      liguistLanguageId: 64,
      name: "ColdFusion",
      namespace: "cfml",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.cfm",
      vscodeLanguages: [
        "cfml",
        "cfmhtml"
      ]
    },
    {
      aceMode: "coldfusion",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cfc"
      ],
      fileNames: [],
      group: "ColdFusion",
      liguistLanguageId: 65,
      name: "ColdFusion CFC",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cfscript",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".asd",
        ".cl",
        ".l",
        ".lisp",
        ".lsp",
        ".ny",
        ".podsl",
        ".sexp"
      ],
      fileNames: [],
      liguistLanguageId: 66,
      name: "Common Lisp",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".cwl"
      ],
      fileNames: [],
      liguistLanguageId: 988547172,
      name: "Common Workflow Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cwl",
      vscodeLanguages: []
    },
    {
      aceMode: "pascal",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-pascal",
      codeMirrorMode: "pascal",
      extensions: [
        ".cp",
        ".cps"
      ],
      fileNames: [],
      liguistLanguageId: 67,
      name: "Component Pascal",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pascal",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cl"
      ],
      fileNames: [],
      liguistLanguageId: 68,
      name: "Cool",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cool",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".coq",
        ".v"
      ],
      fileNames: [],
      liguistLanguageId: 69,
      name: "Coq",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".c++-objdump",
        ".c++objdump",
        ".cpp-objdump",
        ".cppobjdump",
        ".cxx-objdump"
      ],
      fileNames: [],
      liguistLanguageId: 70,
      name: "Cpp-ObjDump",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "objdump.x86asm",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".creole"
      ],
      fileNames: [],
      liguistLanguageId: 71,
      name: "Creole",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.creole",
      vscodeLanguages: []
    },
    {
      aceMode: "ruby",
      aliases: [],
      atomGrammars: [
        "Crystal"
      ],
      codeMirrorMimeType: "text/x-crystal",
      codeMirrorMode: "crystal",
      extensions: [
        ".cr"
      ],
      fileNames: [],
      liguistLanguageId: 72,
      name: "Crystal",
      namespace: "crystal",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.crystal",
      vscodeLanguages: []
    },
    {
      aceMode: "csound_orchestra",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".orc",
        ".udo"
      ],
      fileNames: [],
      liguistLanguageId: 73,
      name: "Csound",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.csound",
      vscodeLanguages: []
    },
    {
      aceMode: "csound_document",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".csd"
      ],
      fileNames: [],
      liguistLanguageId: 74,
      name: "Csound Document",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.csound-document",
      vscodeLanguages: []
    },
    {
      aceMode: "csound_score",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sco"
      ],
      fileNames: [],
      liguistLanguageId: 75,
      name: "Csound Score",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.csound-score",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".cu",
        ".cuh"
      ],
      fileNames: [],
      liguistLanguageId: 77,
      name: "Cuda",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cuda-c++",
      vscodeLanguages: []
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/javascript",
      codeMirrorMode: "javascript",
      extensions: [
        ".cy"
      ],
      fileNames: [],
      liguistLanguageId: 78,
      name: "Cycript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-cython",
      codeMirrorMode: "python",
      extensions: [
        ".pxd",
        ".pxi",
        ".pyx"
      ],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 79,
      name: "Cython",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "d",
      aliases: [],
      atomGrammars: [
        "D"
      ],
      codeMirrorMimeType: "text/x-d",
      codeMirrorMode: "d",
      extensions: [
        ".d",
        ".di"
      ],
      fileNames: [],
      liguistLanguageId: 80,
      name: "D",
      namespace: "d",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".d-objdump"
      ],
      fileNames: [],
      liguistLanguageId: 81,
      name: "D-ObjDump",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "objdump.x86asm",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".com"
      ],
      fileNames: [],
      liguistLanguageId: 82,
      name: "DIGITAL Command Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".dm"
      ],
      fileNames: [],
      liguistLanguageId: 83,
      name: "DM",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.dm",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".arpa",
        ".zone"
      ],
      fileNames: [],
      liguistLanguageId: 84,
      name: "DNS Zone",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.zone_file",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".d"
      ],
      fileNames: [],
      liguistLanguageId: 85,
      name: "DTrace",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".darcspatch",
        ".dpatch"
      ],
      fileNames: [],
      liguistLanguageId: 86,
      name: "Darcs Patch",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "dart",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/dart",
      codeMirrorMode: "dart",
      extensions: [
        ".dart"
      ],
      fileNames: [],
      liguistLanguageId: 87,
      name: "Dart",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".dwl"
      ],
      fileNames: [],
      liguistLanguageId: 974514097,
      name: "DataWeave",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.data-weave",
      vscodeLanguages: []
    },
    {
      aceMode: "diff",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-diff",
      codeMirrorMode: "diff",
      extensions: [
        ".diff",
        ".patch"
      ],
      fileNames: [],
      liguistLanguageId: 88,
      name: "Diff",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.diff",
      vscodeLanguages: [
        "diff"
      ]
    },
    {
      aceMode: "dockerfile",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-dockerfile",
      codeMirrorMode: "dockerfile",
      extensions: [
        ".dockerfile"
      ],
      fileNames: [
        "Dockerfile"
      ],
      liguistLanguageId: 89,
      name: "Dockerfile",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.dockerfile",
      vscodeLanguages: [
        "dockerfile"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".djs"
      ],
      fileNames: [],
      liguistLanguageId: 90,
      name: "Dogescript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-dylan",
      codeMirrorMode: "dylan",
      extensions: [
        ".dyl",
        ".dylan",
        ".intr",
        ".lid"
      ],
      fileNames: [],
      liguistLanguageId: 91,
      name: "Dylan",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".E"
      ],
      fileNames: [],
      liguistLanguageId: 92,
      name: "E",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ebnf",
      codeMirrorMode: "ebnf",
      extensions: [
        ".ebnf"
      ],
      fileNames: [],
      liguistLanguageId: 430,
      name: "EBNF",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ebnf",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ecl",
      codeMirrorMode: "ecl",
      extensions: [
        ".ecl",
        ".eclxml"
      ],
      fileNames: [],
      liguistLanguageId: 93,
      name: "ECL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "prolog",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ecl"
      ],
      fileNames: [],
      group: "prolog",
      liguistLanguageId: 94,
      name: "ECLiPSe",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.prolog.eclipse",
      vscodeLanguages: []
    },
    {
      aceMode: "ejs",
      aliases: [],
      atomGrammars: [
        "HTML (Angular)",
        "JavaScript Template"
      ],
      extensions: [
        ".ejs"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 95,
      name: "EJS",
      namespace: "ejs",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.js",
      vscodeLanguages: []
    },
    {
      aceMode: "csharp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csharp",
      codeMirrorMode: "clike",
      extensions: [
        ".eq"
      ],
      fileNames: [],
      liguistLanguageId: 96,
      name: "EQ",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cs",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".brd",
        ".sch"
      ],
      fileNames: [],
      liguistLanguageId: 97,
      name: "Eagle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "python",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-python",
      codeMirrorMode: "python",
      extensions: [
        ".eb"
      ],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 342840477,
      name: "Easybuild",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.python",
      vscodeLanguages: []
    },
    {
      aceMode: "json",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".epj"
      ],
      fileNames: [],
      group: "JavaScript",
      liguistLanguageId: 98,
      name: "Ecere Projects",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.json",
      vscodeLanguages: []
    },
    {
      aceMode: "json",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".edc"
      ],
      fileNames: [],
      liguistLanguageId: 342840478,
      name: "Edje Data Collection",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.json",
      vscodeLanguages: []
    },
    {
      aceMode: "eiffel",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-eiffel",
      codeMirrorMode: "eiffel",
      extensions: [
        ".e"
      ],
      fileNames: [],
      liguistLanguageId: 99,
      name: "Eiffel",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "elixir",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ex",
        ".exs"
      ],
      fileNames: [
        "mix.lock"
      ],
      liguistLanguageId: 100,
      name: "Elixir",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "elm",
      aliases: [],
      atomGrammars: [
        "Elm"
      ],
      codeMirrorMimeType: "text/x-elm",
      codeMirrorMode: "elm",
      extensions: [
        ".elm"
      ],
      fileNames: [],
      liguistLanguageId: 101,
      name: "Elm",
      namespace: "elm",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.elm",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".el",
        ".emacs",
        ".emacs.desktop"
      ],
      fileNames: [
        ".abbrev_defs",
        ".emacs",
        ".emacs.desktop",
        ".gnus",
        ".spacemacs",
        ".viper",
        "Cask",
        "Project.ede",
        "_emacs",
        "abbrev_defs"
      ],
      liguistLanguageId: 102,
      name: "Emacs Lisp",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.emacs.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "coffee",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-coffeescript",
      codeMirrorMode: "coffeescript",
      extensions: [
        ".em",
        ".emberscript"
      ],
      fileNames: [],
      liguistLanguageId: 103,
      name: "EmberScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.coffee",
      vscodeLanguages: []
    },
    {
      aceMode: "erlang",
      aliases: [],
      atomGrammars: [
        "Erlang"
      ],
      codeMirrorMimeType: "text/x-erlang",
      codeMirrorMode: "erlang",
      extensions: [
        ".app.src",
        ".erl",
        ".es",
        ".escript",
        ".hrl",
        ".xrl",
        ".yrl"
      ],
      fileNames: [
        "Emakefile",
        "rebar.config",
        "rebar.config.lock",
        "rebar.lock"
      ],
      liguistLanguageId: 104,
      name: "Erlang",
      namespace: "erlang",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-fsharp",
      codeMirrorMode: "mllike",
      extensions: [
        ".fs",
        ".fsi",
        ".fsx"
      ],
      fileNames: [],
      liguistLanguageId: 105,
      name: "F#",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.fsharp",
      vscodeLanguages: [
        "fsharp"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".flux",
        ".fx"
      ],
      fileNames: [],
      liguistLanguageId: 106,
      name: "FLUX",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-factor",
      codeMirrorMode: "factor",
      extensions: [
        ".factor"
      ],
      fileNames: [
        ".factor-boot-rc",
        ".factor-rc"
      ],
      liguistLanguageId: 108,
      name: "Factor",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fancypack",
        ".fy"
      ],
      fileNames: [
        "Fakefile"
      ],
      liguistLanguageId: 109,
      name: "Fancy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fan"
      ],
      fileNames: [],
      liguistLanguageId: 110,
      name: "Fantom",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.fan",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".f"
      ],
      fileNames: [],
      liguistLanguageId: 111,
      name: "Filebench WML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fs"
      ],
      fileNames: [],
      group: "RenderScript",
      liguistLanguageId: 112,
      name: "Filterscript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".eam.fs",
        ".for"
      ],
      fileNames: [],
      liguistLanguageId: 113,
      name: "Formatted",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "forth",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-forth",
      codeMirrorMode: "forth",
      extensions: [
        ".4th",
        ".f",
        ".for",
        ".forth",
        ".fr",
        ".frt",
        ".fs",
        ".fth"
      ],
      fileNames: [],
      liguistLanguageId: 114,
      name: "Forth",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "Fortran - Modern"
      ],
      codeMirrorMimeType: "text/x-fortran",
      codeMirrorMode: "fortran",
      extensions: [
        ".F90",
        ".f",
        ".f03",
        ".f08",
        ".f77",
        ".f90",
        ".f95",
        ".for",
        ".fpp"
      ],
      fileNames: [],
      liguistLanguageId: 107,
      name: "Fortran",
      namespace: "fortran",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.fortran.modern",
      vscodeLanguages: []
    },
    {
      aceMode: "ftl",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ftl"
      ],
      fileNames: [],
      liguistLanguageId: 115,
      name: "FreeMarker",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.ftl",
      vscodeLanguages: []
    },
    {
      aceMode: "haskell",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fr"
      ],
      fileNames: [],
      liguistLanguageId: 116,
      name: "Frege",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.haskell",
      vscodeLanguages: []
    },
    {
      aceMode: "gcode",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".g",
        ".gco",
        ".gcode"
      ],
      fileNames: [],
      liguistLanguageId: 117,
      name: "G-code",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gcode",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gms"
      ],
      fileNames: [],
      liguistLanguageId: 118,
      name: "GAMS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".g",
        ".gap",
        ".gd",
        ".gi",
        ".tst"
      ],
      fileNames: [],
      liguistLanguageId: 119,
      name: "GAP",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gap",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".md"
      ],
      fileNames: [],
      liguistLanguageId: 121,
      name: "GCC Machine Description",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gdb",
        ".gdbinit"
      ],
      fileNames: [],
      liguistLanguageId: 122,
      name: "GDB",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gdb",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gd"
      ],
      fileNames: [],
      liguistLanguageId: 123,
      name: "GDScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gdscript",
      vscodeLanguages: []
    },
    {
      aceMode: "glsl",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fp",
        ".frag",
        ".frg",
        ".fs",
        ".fsh",
        ".fshader",
        ".geo",
        ".geom",
        ".glsl",
        ".glslv",
        ".gshader",
        ".shader",
        ".tesc",
        ".tese",
        ".vert",
        ".vrx",
        ".vsh",
        ".vshader"
      ],
      fileNames: [],
      liguistLanguageId: 124,
      name: "GLSL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "python",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-python",
      codeMirrorMode: "python",
      extensions: [
        ".gn",
        ".gni"
      ],
      fileNames: [],
      liguistLanguageId: 302957008,
      name: "GN",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gn",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".gml"
      ],
      fileNames: [],
      liguistLanguageId: 125,
      name: "Game Maker Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c++",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gs"
      ],
      fileNames: [],
      liguistLanguageId: 792408528,
      name: "Genie",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".kid"
      ],
      fileNames: [],
      liguistLanguageId: 126,
      name: "Genshi",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml.genshi",
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [
        ".ebuild"
      ],
      fileNames: [],
      group: "Shell",
      liguistLanguageId: 127,
      name: "Gentoo Ebuild",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shell",
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [
        ".eclass"
      ],
      fileNames: [],
      group: "Shell",
      liguistLanguageId: 128,
      name: "Gentoo Eclass",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shell",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gbl",
        ".gbo",
        ".gbp",
        ".gbr",
        ".gbs",
        ".gko",
        ".gpb",
        ".gpt",
        ".gtl",
        ".gto",
        ".gtp",
        ".gts"
      ],
      fileNames: [],
      liguistLanguageId: 404627610,
      name: "Gerber Image",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gerber",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".po",
        ".pot"
      ],
      fileNames: [],
      liguistLanguageId: 129,
      name: "Gettext Catalog",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.po",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "Gherkin"
      ],
      extensions: [
        ".feature"
      ],
      fileNames: [],
      liguistLanguageId: 76,
      name: "Gherkin",
      namespace: "gherkin",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.gherkin.feature",
      vscodeLanguages: []
    },
    {
      aceMode: "tcl",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-tcl",
      codeMirrorMode: "tcl",
      extensions: [
        ".glf"
      ],
      fileNames: [],
      liguistLanguageId: 130,
      name: "Glyph",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.tcl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gnu",
        ".gnuplot",
        ".gp",
        ".plot",
        ".plt"
      ],
      fileNames: [],
      liguistLanguageId: 131,
      name: "Gnuplot",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "golang",
      aliases: [],
      atomGrammars: [
        "Go"
      ],
      codeMirrorMimeType: "text/x-go",
      codeMirrorMode: "go",
      extensions: [
        ".go"
      ],
      fileNames: [],
      liguistLanguageId: 132,
      name: "Go",
      namespace: "go",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "go"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".golo"
      ],
      fileNames: [],
      liguistLanguageId: 133,
      name: "Golo",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.golo",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gs",
        ".gst",
        ".gsx",
        ".vark"
      ],
      fileNames: [],
      liguistLanguageId: 134,
      name: "Gosu",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gosu.2",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".grace"
      ],
      fileNames: [],
      liguistLanguageId: 135,
      name: "Grace",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.grace",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gradle"
      ],
      fileNames: [],
      liguistLanguageId: 136,
      name: "Gradle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.groovy.gradle",
      vscodeLanguages: []
    },
    {
      aceMode: "haskell",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-haskell",
      codeMirrorMode: "haskell",
      extensions: [
        ".gf"
      ],
      fileNames: [],
      liguistLanguageId: 137,
      name: "Grammatical Framework",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.haskell",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gml"
      ],
      fileNames: [],
      liguistLanguageId: 138,
      name: "Graph Modeling Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".gql",
        ".graphql"
      ],
      fileNames: [],
      liguistLanguageId: 139,
      name: "GraphQL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.graphql",
      vscodeLanguages: [
        "graphql"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".dot",
        ".gv"
      ],
      fileNames: [],
      liguistLanguageId: 140,
      name: "Graphviz (DOT)",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.dot",
      vscodeLanguages: []
    },
    {
      aceMode: "groovy",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-groovy",
      codeMirrorMode: "groovy",
      extensions: [
        ".groovy",
        ".grt",
        ".gtpl",
        ".gvy"
      ],
      fileNames: [
        "Jenkinsfile"
      ],
      liguistLanguageId: 142,
      name: "Groovy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "groovy"
      ]
    },
    {
      aceMode: "jsp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-jsp",
      codeMirrorMode: "htmlembedded",
      extensions: [
        ".gsp"
      ],
      fileNames: [],
      group: "Groovy",
      liguistLanguageId: 143,
      name: "Groovy Server Pages",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.jsp",
      vscodeLanguages: []
    },
    {
      aceMode: "ruby",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ruby",
      codeMirrorMode: "ruby",
      extensions: [
        ".hcl",
        ".tf",
        ".tfvars"
      ],
      fileNames: [],
      liguistLanguageId: 144,
      name: "HCL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.terraform",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cginc",
        ".fx",
        ".fxh",
        ".hlsl",
        ".hlsli"
      ],
      fileNames: [],
      liguistLanguageId: 145,
      name: "HLSL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.hlsl",
      vscodeLanguages: []
    },
    {
      aceMode: "html",
      aliases: [],
      atomGrammars: [
        "HTML"
      ],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".htm",
        ".html",
        ".html.hl",
        ".inc",
        ".st",
        ".xht",
        ".xhtml"
      ],
      fileNames: [],
      liguistLanguageId: 146,
      name: "HTML",
      namespace: "html",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.basic",
      vscodeLanguages: [
        "html"
      ]
    },
    {
      aceMode: "django",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-django",
      codeMirrorMode: "django",
      extensions: [
        ".jinja",
        ".jinja2",
        ".mustache",
        ".njk"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 147,
      name: "HTML+Django",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.django",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".ecr"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 148,
      name: "HTML+ECR",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.ecr",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".eex"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 149,
      name: "HTML+EEX",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.elixir",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "HTML (Rails)",
        "HTML (Ruby - ERB)"
      ],
      codeMirrorMimeType: "application/x-erb",
      codeMirrorMode: "htmlembedded",
      extensions: [
        ".erb",
        ".erb.deface"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 150,
      name: "HTML+ERB",
      namespace: "erb",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.erb",
      vscodeLanguages: []
    },
    {
      aceMode: "php",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-httpd-php",
      codeMirrorMode: "php",
      extensions: [
        ".phtml"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 151,
      name: "HTML+PHP",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.php",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "message/http",
      codeMirrorMode: "http",
      extensions: [
        ".http"
      ],
      fileNames: [],
      liguistLanguageId: 152,
      name: "HTTP",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.httpspec",
      vscodeLanguages: []
    },
    {
      aceMode: "php",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-httpd-php",
      codeMirrorMode: "php",
      extensions: [
        ".hh",
        ".php"
      ],
      fileNames: [],
      liguistLanguageId: 153,
      name: "Hack",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.php",
      vscodeLanguages: []
    },
    {
      aceMode: "haml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-haml",
      codeMirrorMode: "haml",
      extensions: [
        ".haml",
        ".haml.deface"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 154,
      name: "Haml",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "handlebars",
      aliases: [],
      atomGrammars: [
        "HTML (Handlebars)",
        "Handlebars"
      ],
      extensions: [
        ".handlebars",
        ".hbs"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 155,
      name: "Handlebars",
      namespace: "handlebars",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.handlebars",
      vscodeLanguages: [
        "handlebars"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".hb"
      ],
      fileNames: [],
      liguistLanguageId: 156,
      name: "Harbour",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.harbour",
      vscodeLanguages: []
    },
    {
      aceMode: "haskell",
      aliases: [],
      atomGrammars: [
        "Haskell"
      ],
      codeMirrorMimeType: "text/x-haskell",
      codeMirrorMode: "haskell",
      extensions: [
        ".hs",
        ".hsc"
      ],
      fileNames: [],
      liguistLanguageId: 157,
      name: "Haskell",
      namespace: "haskell",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "haxe",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-haxe",
      codeMirrorMode: "haxe",
      extensions: [
        ".hx",
        ".hxsl"
      ],
      fileNames: [],
      liguistLanguageId: 158,
      name: "Haxe",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.haxe.2",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".hy"
      ],
      fileNames: [],
      liguistLanguageId: 159,
      name: "Hy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".bf"
      ],
      fileNames: [],
      liguistLanguageId: 160,
      name: "HyPhy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-idl",
      codeMirrorMode: "idl",
      extensions: [
        ".dlm",
        ".pro"
      ],
      fileNames: [],
      liguistLanguageId: 161,
      name: "IDL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ipf"
      ],
      fileNames: [],
      liguistLanguageId: 162,
      name: "IGOR Pro",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "ini",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-properties",
      codeMirrorMode: "properties",
      extensions: [
        ".cfg",
        ".ini",
        ".prefs",
        ".pro",
        ".properties"
      ],
      fileNames: [
        "buildozer.spec"
      ],
      liguistLanguageId: 163,
      name: "INI",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ini",
      vscodeLanguages: [
        "ini"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/mirc",
      codeMirrorMode: "mirc",
      extensions: [
        ".irclog",
        ".weechatlog"
      ],
      fileNames: [],
      liguistLanguageId: 164,
      name: "IRC log",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".idr",
        ".lidr"
      ],
      fileNames: [],
      liguistLanguageId: 165,
      name: "Idris",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.idris",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".i7x",
        ".ni"
      ],
      fileNames: [],
      liguistLanguageId: 166,
      name: "Inform 7",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.inform7",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".iss"
      ],
      fileNames: [],
      liguistLanguageId: 167,
      name: "Inno Setup",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "io",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".io"
      ],
      fileNames: [],
      liguistLanguageId: 168,
      name: "Io",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ik"
      ],
      fileNames: [],
      liguistLanguageId: 169,
      name: "Ioke",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".thy"
      ],
      fileNames: [],
      liguistLanguageId: 170,
      name: "Isabelle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.isabelle.theory",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [],
      fileNames: [
        "ROOT"
      ],
      group: "Isabelle",
      liguistLanguageId: 171,
      name: "Isabelle ROOT",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.isabelle.root",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ijs"
      ],
      fileNames: [],
      liguistLanguageId: 172,
      name: "J",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.j",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".flex",
        ".jflex"
      ],
      fileNames: [],
      group: "Lex",
      liguistLanguageId: 173,
      name: "JFlex",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jflex",
      vscodeLanguages: []
    },
    {
      aceMode: "json",
      aliases: [],
      atomGrammars: [
        "JSON"
      ],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".JSON-tmLanguage",
        ".avsc",
        ".geojson",
        ".gltf",
        ".json",
        ".jsonl",
        ".tfstate",
        ".tfstate.backup",
        ".topojson",
        ".webapp",
        ".webmanifest"
      ],
      fileNames: [
        ".arcconfig",
        ".htmlhintrc",
        ".jscsrc",
        ".jshintrc",
        ".tern-config",
        ".tern-project",
        "composer.lock",
        "mcmod.info"
      ],
      group: "JavaScript",
      liguistLanguageId: 174,
      name: "JSON",
      namespace: "json",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.json",
      vscodeLanguages: [
        "json",
        "jsonc"
      ]
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".json5"
      ],
      fileNames: [
        ".babelrc",
        ".jslintrc"
      ],
      liguistLanguageId: 175,
      name: "JSON5",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js",
      vscodeLanguages: []
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".jsonld"
      ],
      fileNames: [],
      group: "JavaScript",
      liguistLanguageId: 176,
      name: "JSONLD",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js",
      vscodeLanguages: []
    },
    {
      aceMode: "jsoniq",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".jq"
      ],
      fileNames: [],
      liguistLanguageId: 177,
      name: "JSONiq",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jq",
      vscodeLanguages: []
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [
        "JSX",
        "JavaScript (JSX)"
      ],
      codeMirrorMimeType: "text/jsx",
      codeMirrorMode: "jsx",
      extensions: [
        ".js",
        ".jsx"
      ],
      fileNames: [],
      group: "JavaScript",
      liguistLanguageId: 178,
      name: "JSX",
      namespace: "jsx",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js.jsx",
      vscodeLanguages: [
        "javascriptreact"
      ]
    },
    {
      aceMode: "java",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".j"
      ],
      fileNames: [],
      liguistLanguageId: 180,
      name: "Jasmin",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jasmin",
      vscodeLanguages: []
    },
    {
      aceMode: "java",
      aliases: [],
      atomGrammars: [
        "Java"
      ],
      codeMirrorMimeType: "text/x-java",
      codeMirrorMode: "clike",
      extensions: [
        ".java"
      ],
      fileNames: [],
      liguistLanguageId: 181,
      name: "Java",
      namespace: "java",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "java"
      ]
    },
    {
      aceMode: "jsp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-jsp",
      codeMirrorMode: "htmlembedded",
      extensions: [
        ".jsp"
      ],
      fileNames: [],
      group: "Java",
      liguistLanguageId: 182,
      name: "Java Server Pages",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.jsp",
      vscodeLanguages: []
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [
        "JavaScript"
      ],
      codeMirrorMimeType: "text/javascript",
      codeMirrorMode: "javascript",
      extensions: [
        "._js",
        ".bones",
        ".es",
        ".es6",
        ".frag",
        ".gs",
        ".jake",
        ".js",
        ".jsb",
        ".jscad",
        ".jsfl",
        ".jsm",
        ".jss",
        ".mjs",
        ".njs",
        ".pac",
        ".sjs",
        ".ssjs",
        ".xsjs",
        ".xsjslib"
      ],
      fileNames: [
        "Jakefile"
      ],
      liguistLanguageId: 183,
      name: "JavaScript",
      namespace: "js",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js",
      vscodeLanguages: [
        "javascript"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".jison"
      ],
      fileNames: [],
      group: "Yacc",
      liguistLanguageId: 284531423,
      name: "Jison",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jison",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".jisonlex"
      ],
      fileNames: [],
      group: "Lex",
      liguistLanguageId: 406395330,
      name: "Jison Lex",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jisonlex",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".iol",
        ".ol"
      ],
      fileNames: [],
      liguistLanguageId: 998078858,
      name: "Jolie",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.jolie",
      vscodeLanguages: []
    },
    {
      aceMode: "julia",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-julia",
      codeMirrorMode: "julia",
      extensions: [
        ".jl"
      ],
      fileNames: [],
      liguistLanguageId: 184,
      name: "Julia",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "json",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".ipynb"
      ],
      fileNames: [
        "Notebook"
      ],
      liguistLanguageId: 185,
      name: "Jupyter Notebook",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.json",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".krl"
      ],
      fileNames: [],
      liguistLanguageId: 186,
      name: "KRL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".kicad_mod",
        ".kicad_pcb",
        ".kicad_wks"
      ],
      fileNames: [
        "fp-lib-table"
      ],
      liguistLanguageId: 187,
      name: "KiCad Layout",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pcb.sexp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".brd"
      ],
      fileNames: [],
      liguistLanguageId: 140848857,
      name: "KiCad Legacy Layout",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pcb.board",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sch"
      ],
      fileNames: [],
      liguistLanguageId: 622447435,
      name: "KiCad Schematic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pcb.schematic",
      vscodeLanguages: []
    },
    {
      aceMode: "html",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".kit"
      ],
      fileNames: [],
      liguistLanguageId: 188,
      name: "Kit",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.basic",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-kotlin",
      codeMirrorMode: "clike",
      extensions: [
        ".kt",
        ".ktm",
        ".kts"
      ],
      fileNames: [],
      liguistLanguageId: 189,
      name: "Kotlin",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.Kotlin",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".lfe"
      ],
      fileNames: [],
      liguistLanguageId: 190,
      name: "LFE",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ll"
      ],
      fileNames: [],
      liguistLanguageId: 191,
      name: "LLVM",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".lol"
      ],
      fileNames: [],
      liguistLanguageId: 192,
      name: "LOLCODE",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "lsl",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".lsl",
        ".lslp"
      ],
      fileNames: [],
      liguistLanguageId: 193,
      name: "LSL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".lvproj"
      ],
      fileNames: [],
      liguistLanguageId: 194,
      name: "LabVIEW",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".las",
        ".lasso",
        ".lasso8",
        ".lasso9",
        ".ldml"
      ],
      fileNames: [],
      liguistLanguageId: 195,
      name: "Lasso",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "file.lasso",
      vscodeLanguages: []
    },
    {
      aceMode: "smarty",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-smarty",
      codeMirrorMode: "smarty",
      extensions: [
        ".latte"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 196,
      name: "Latte",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.smarty",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".hlean",
        ".lean"
      ],
      fileNames: [],
      liguistLanguageId: 197,
      name: "Lean",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "less",
      aliases: [],
      atomGrammars: [
        "LESS"
      ],
      codeMirrorMimeType: "text/css",
      codeMirrorMode: "css",
      extensions: [
        ".less"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 198,
      name: "Less",
      namespace: "less",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.css.less",
      vscodeLanguages: [
        "less"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".l",
        ".lex"
      ],
      fileNames: [],
      liguistLanguageId: 199,
      name: "Lex",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ily",
        ".ly"
      ],
      fileNames: [],
      liguistLanguageId: 200,
      name: "LilyPond",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".b",
        ".m"
      ],
      fileNames: [],
      liguistLanguageId: 201,
      name: "Limbo",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ld",
        ".lds",
        ".x"
      ],
      fileNames: [
        "ld.script"
      ],
      liguistLanguageId: 202,
      name: "Linker Script",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mod"
      ],
      fileNames: [],
      liguistLanguageId: 203,
      name: "Linux Kernel Module",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "liquid",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".liquid"
      ],
      fileNames: [],
      liguistLanguageId: 204,
      name: "Liquid",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.liquid",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".lagda"
      ],
      fileNames: [],
      group: "Agda",
      liguistLanguageId: 205,
      name: "Literate Agda",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".litcoffee"
      ],
      fileNames: [],
      group: "CoffeeScript",
      liguistLanguageId: 206,
      name: "Literate CoffeeScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.litcoffee",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-literate-haskell",
      codeMirrorMode: "haskell-literate",
      extensions: [
        ".lhs"
      ],
      fileNames: [],
      group: "Haskell",
      liguistLanguageId: 207,
      name: "Literate Haskell",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.tex.latex.haskell",
      vscodeLanguages: []
    },
    {
      aceMode: "livescript",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-livescript",
      codeMirrorMode: "livescript",
      extensions: [
        "._ls",
        ".ls"
      ],
      fileNames: [
        "Slakefile"
      ],
      liguistLanguageId: 208,
      name: "LiveScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".x",
        ".xi",
        ".xm"
      ],
      fileNames: [],
      liguistLanguageId: 209,
      name: "Logos",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.logos",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".lgt",
        ".logtalk"
      ],
      fileNames: [],
      liguistLanguageId: 210,
      name: "Logtalk",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".lookml",
        ".model.lkml",
        ".view.lkml"
      ],
      fileNames: [],
      liguistLanguageId: 211,
      name: "LookML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yaml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ls"
      ],
      fileNames: [],
      liguistLanguageId: 212,
      name: "LoomScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.loomscript",
      vscodeLanguages: []
    },
    {
      aceMode: "lua",
      aliases: [],
      atomGrammars: [
        "Lua"
      ],
      codeMirrorMimeType: "text/x-lua",
      codeMirrorMode: "lua",
      extensions: [
        ".fcgi",
        ".lua",
        ".nse",
        ".pd_lua",
        ".rbxs",
        ".wlua"
      ],
      fileNames: [],
      liguistLanguageId: 213,
      name: "Lua",
      namespace: "lua",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "lua"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-mumps",
      codeMirrorMode: "mumps",
      extensions: [
        ".m",
        ".mumps"
      ],
      fileNames: [],
      liguistLanguageId: 214,
      name: "M",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".m4"
      ],
      fileNames: [],
      liguistLanguageId: 215,
      name: "M4",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".m4"
      ],
      fileNames: [
        "configure.ac"
      ],
      group: "M4",
      liguistLanguageId: 216,
      name: "M4Sugar",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mcr",
        ".ms"
      ],
      fileNames: [],
      liguistLanguageId: 217,
      name: "MAXScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.maxscript",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mq4",
        ".mqh"
      ],
      fileNames: [],
      liguistLanguageId: 426,
      name: "MQL4",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.mql5",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mq5",
        ".mqh"
      ],
      fileNames: [],
      liguistLanguageId: 427,
      name: "MQL5",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.mql5",
      vscodeLanguages: []
    },
    {
      aceMode: "html",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".mtml"
      ],
      fileNames: [],
      liguistLanguageId: 218,
      name: "MTML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.basic",
      vscodeLanguages: []
    },
    {
      aceMode: "forth",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-forth",
      codeMirrorMode: "forth",
      extensions: [
        ".m",
        ".muf"
      ],
      fileNames: [],
      group: "Forth",
      liguistLanguageId: 219,
      name: "MUF",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "makefile",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-cmake",
      codeMirrorMode: "cmake",
      extensions: [
        ".d",
        ".mak",
        ".make",
        ".mk",
        ".mkfile"
      ],
      fileNames: [
        "BSDmakefile",
        "GNUmakefile",
        "Kbuild",
        "Makefile",
        "Makefile.am",
        "Makefile.boot",
        "Makefile.frag",
        "Makefile.in",
        "Makefile.inc",
        "Makefile.wat",
        "makefile",
        "makefile.sco",
        "mkfile"
      ],
      liguistLanguageId: 220,
      name: "Makefile",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "makefile"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mako",
        ".mao"
      ],
      fileNames: [],
      liguistLanguageId: 221,
      name: "Mako",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.mako",
      vscodeLanguages: []
    },
    {
      aceMode: "markdown",
      aliases: [],
      atomGrammars: [
        "GitHub Markdown"
      ],
      codeMirrorMimeType: "text/x-gfm",
      codeMirrorMode: "gfm",
      extensions: [
        ".markdown",
        ".md",
        ".mdown",
        ".mdwn",
        ".mkd",
        ".mkdn",
        ".mkdown",
        ".ron",
        ".workbook"
      ],
      fileNames: [],
      liguistLanguageId: 222,
      name: "Markdown",
      namespace: "markdown",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gfm",
      vscodeLanguages: [
        "markdown"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "Marko"
      ],
      codeMirrorMimeType: "text/html",
      codeMirrorMode: "htmlmixed",
      extensions: [
        ".marko"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 932782397,
      name: "Marko",
      namespace: "marko",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.marko",
      vscodeLanguages: []
    },
    {
      aceMode: "mask",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mask"
      ],
      fileNames: [],
      liguistLanguageId: 223,
      name: "Mask",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.mask",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-mathematica",
      codeMirrorMode: "mathematica",
      extensions: [
        ".cdf",
        ".m",
        ".ma",
        ".mathematica",
        ".mt",
        ".nb",
        ".nbp",
        ".wl",
        ".wlt"
      ],
      fileNames: [],
      liguistLanguageId: 224,
      name: "Mathematica",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "matlab",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-octave",
      codeMirrorMode: "octave",
      extensions: [
        ".m",
        ".matlab"
      ],
      fileNames: [],
      liguistLanguageId: 225,
      name: "Matlab",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [],
      fileNames: [
        "pom.xml"
      ],
      liguistLanguageId: 226,
      name: "Maven POM",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml.pom",
      vscodeLanguages: []
    },
    {
      aceMode: "json",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/json",
      codeMirrorMode: "javascript",
      extensions: [
        ".maxhelp",
        ".maxpat",
        ".maxproj",
        ".mxt",
        ".pat"
      ],
      fileNames: [],
      liguistLanguageId: 227,
      name: "Max",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.json",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mediawiki",
        ".wiki"
      ],
      fileNames: [],
      liguistLanguageId: 228,
      name: "MediaWiki",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.mediawiki",
      vscodeLanguages: []
    },
    {
      aceMode: "prolog",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".m",
        ".moo"
      ],
      fileNames: [],
      liguistLanguageId: 229,
      name: "Mercury",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.mercury",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [],
      fileNames: [
        "meson.build",
        "meson_options.txt"
      ],
      liguistLanguageId: 799141244,
      name: "Meson",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.meson",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".metal"
      ],
      fileNames: [],
      liguistLanguageId: 230,
      name: "Metal",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c++",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".minid"
      ],
      fileNames: [],
      liguistLanguageId: 231,
      name: "MiniD",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "ruby",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ruby",
      codeMirrorMode: "ruby",
      extensions: [
        ".druby",
        ".duby",
        ".mir",
        ".mirah"
      ],
      fileNames: [],
      liguistLanguageId: 232,
      name: "Mirah",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ruby",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-modelica",
      codeMirrorMode: "modelica",
      extensions: [
        ".mo"
      ],
      fileNames: [],
      liguistLanguageId: 233,
      name: "Modelica",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.modelica",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mod"
      ],
      fileNames: [],
      liguistLanguageId: 234,
      name: "Modula-2",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.modula2",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mmk",
        ".mms"
      ],
      fileNames: [
        "descrip.mmk",
        "descrip.mms"
      ],
      liguistLanguageId: 235,
      name: "Module Management System",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".monkey",
        ".monkey2"
      ],
      fileNames: [],
      liguistLanguageId: 236,
      name: "Monkey",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.monkey",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".moo"
      ],
      fileNames: [],
      liguistLanguageId: 237,
      name: "Moocode",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".moon"
      ],
      fileNames: [],
      liguistLanguageId: 238,
      name: "MoonScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      atomGrammars: [
        "HTML (Mustache)"
      ],
      extensions: [
        ".mustache"
      ],
      name: "Mustache",
      namespace: "mustache",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".myt"
      ],
      fileNames: [],
      liguistLanguageId: 239,
      name: "Myghty",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ncl"
      ],
      fileNames: [],
      liguistLanguageId: 240,
      name: "NCL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ncl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nl"
      ],
      fileNames: [],
      liguistLanguageId: 241,
      name: "NL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-nsis",
      codeMirrorMode: "nsis",
      extensions: [
        ".nsh",
        ".nsi"
      ],
      fileNames: [],
      liguistLanguageId: 242,
      name: "NSIS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ne",
        ".nearley"
      ],
      fileNames: [],
      liguistLanguageId: 521429430,
      name: "Nearley",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ne",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".n"
      ],
      fileNames: [],
      liguistLanguageId: 243,
      name: "Nemerle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".axi",
        ".axs"
      ],
      fileNames: [],
      liguistLanguageId: 244,
      name: "NetLinx",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.netlinx",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".axi.erb",
        ".axs.erb"
      ],
      fileNames: [],
      liguistLanguageId: 245,
      name: "NetLinx+ERB",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.netlinx.erb",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".nlogo"
      ],
      fileNames: [],
      liguistLanguageId: 246,
      name: "NetLogo",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".lisp",
        ".lsp",
        ".nl"
      ],
      fileNames: [],
      liguistLanguageId: 247,
      name: "NewLisp",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "groovy",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nf"
      ],
      fileNames: [
        "nextflow.config"
      ],
      liguistLanguageId: 506780613,
      name: "Nextflow",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nextflow",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-nginx-conf",
      codeMirrorMode: "nginx",
      extensions: [
        ".nginxconf",
        ".vhost"
      ],
      fileNames: [
        "nginx.conf"
      ],
      liguistLanguageId: 248,
      name: "Nginx",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nginx",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nim",
        ".nimrod"
      ],
      fileNames: [],
      liguistLanguageId: 249,
      name: "Nim",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nim",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ninja"
      ],
      fileNames: [],
      liguistLanguageId: 250,
      name: "Ninja",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ninja",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nit"
      ],
      fileNames: [],
      liguistLanguageId: 251,
      name: "Nit",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nit",
      vscodeLanguages: []
    },
    {
      aceMode: "nix",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nix"
      ],
      fileNames: [],
      liguistLanguageId: 252,
      name: "Nix",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nix",
      vscodeLanguages: []
    },
    {
      aceMode: "scheme",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-scheme",
      codeMirrorMode: "scheme",
      extensions: [
        ".nu"
      ],
      fileNames: [
        "Nukefile"
      ],
      liguistLanguageId: 253,
      name: "Nu",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nu",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-python",
      codeMirrorMode: "python",
      extensions: [
        ".numpy",
        ".numpyw",
        ".numsc"
      ],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 254,
      name: "NumPy",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "ocaml",
      aliases: [],
      atomGrammars: [
        "OCaml"
      ],
      codeMirrorMimeType: "text/x-ocaml",
      codeMirrorMode: "mllike",
      extensions: [
        ".eliom",
        ".eliomi",
        ".ml",
        ".ml4",
        ".mli",
        ".mll",
        ".mly"
      ],
      fileNames: [],
      liguistLanguageId: 255,
      name: "OCaml",
      namespace: "ocaml",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ocaml",
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".objdump"
      ],
      fileNames: [],
      liguistLanguageId: 256,
      name: "ObjDump",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "objdump.x86asm",
      vscodeLanguages: []
    },
    {
      aceMode: "objectivec",
      aliases: [],
      atomGrammars: [
        "Objective-C",
        "Objective-C++"
      ],
      codeMirrorMimeType: "text/x-objectivec",
      codeMirrorMode: "clike",
      extensions: [
        ".h",
        ".m",
        ".mm"
      ],
      fileNames: [],
      liguistLanguageId: 257,
      name: "Objective-C",
      namespace: "objectivec",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.objc",
      vscodeLanguages: [
        "objective-c"
      ]
    },
    {
      aceMode: "objectivec",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-objectivec",
      codeMirrorMode: "clike",
      extensions: [
        ".mm"
      ],
      fileNames: [],
      liguistLanguageId: 258,
      name: "Objective-C++",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.objc++",
      vscodeLanguages: [
        "objective-cpp"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".j",
        ".sj"
      ],
      fileNames: [],
      liguistLanguageId: 259,
      name: "Objective-J",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js.objj",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".omgrofl"
      ],
      fileNames: [],
      liguistLanguageId: 260,
      name: "Omgrofl",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".opa"
      ],
      fileNames: [],
      liguistLanguageId: 261,
      name: "Opa",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".opal"
      ],
      fileNames: [],
      liguistLanguageId: 262,
      name: "Opal",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.opal",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".cl",
        ".opencl"
      ],
      fileNames: [],
      group: "C",
      liguistLanguageId: 263,
      name: "OpenCL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cls",
        ".p",
        ".w"
      ],
      fileNames: [],
      liguistLanguageId: 264,
      name: "OpenEdge ABL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.abl",
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [],
      fileNames: [],
      group: "Shell",
      liguistLanguageId: 265,
      name: "OpenRC runscript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shell",
      vscodeLanguages: []
    },
    {
      aceMode: "scad",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".scad"
      ],
      fileNames: [],
      liguistLanguageId: 266,
      name: "OpenSCAD",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.scad",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fea"
      ],
      fileNames: [],
      liguistLanguageId: 374317347,
      name: "OpenType Feature File",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.opentype",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".org"
      ],
      fileNames: [],
      liguistLanguageId: 267,
      name: "Org",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ox",
        ".oxh",
        ".oxo"
      ],
      fileNames: [],
      liguistLanguageId: 268,
      name: "Ox",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ox",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".oxygene"
      ],
      fileNames: [],
      liguistLanguageId: 269,
      name: "Oxygene",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-oz",
      codeMirrorMode: "oz",
      extensions: [
        ".oz"
      ],
      fileNames: [],
      liguistLanguageId: 270,
      name: "Oz",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.oz",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".p4"
      ],
      fileNames: [],
      liguistLanguageId: 348895984,
      name: "P4",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.p4",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "Pawn"
      ],
      extensions: [
        ".inc",
        ".pwn"
      ],
      fileNames: [],
      liguistLanguageId: 271,
      name: "PAWN",
      namespace: "pawn",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pawn",
      vscodeLanguages: []
    },
    {
      aceMode: "php",
      aliases: [],
      atomGrammars: [
        "PHP"
      ],
      codeMirrorMimeType: "application/x-httpd-php",
      codeMirrorMode: "php",
      extensions: [
        ".aw",
        ".ctp",
        ".fcgi",
        ".inc",
        ".module",
        ".php",
        ".php3",
        ".php4",
        ".php5",
        ".phps",
        ".phpt"
      ],
      fileNames: [
        ".php_cs",
        ".php_cs.dist",
        "Phakefile"
      ],
      liguistLanguageId: 272,
      name: "PHP",
      namespace: "php",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.php",
      vscodeLanguages: [
        "php"
      ]
    },
    {
      aceMode: "sql",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-plsql",
      codeMirrorMode: "sql",
      extensions: [
        ".bdy",
        ".ddl",
        ".fnc",
        ".pck",
        ".pkb",
        ".pks",
        ".plb",
        ".pls",
        ".plsql",
        ".prc",
        ".spc",
        ".sql",
        ".tpb",
        ".tps",
        ".trg",
        ".vw"
      ],
      fileNames: [],
      liguistLanguageId: 273,
      name: "PLSQL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "pgsql",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sql",
      codeMirrorMode: "sql",
      extensions: [
        ".sql"
      ],
      fileNames: [],
      liguistLanguageId: 274,
      name: "PLpgSQL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sql",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".inc",
        ".pov"
      ],
      fileNames: [],
      liguistLanguageId: 275,
      name: "POV-Ray SDL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pan"
      ],
      fileNames: [],
      liguistLanguageId: 276,
      name: "Pan",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pan",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".psc"
      ],
      fileNames: [],
      liguistLanguageId: 277,
      name: "Papyrus",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.papyrus.skyrim",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".parrot"
      ],
      fileNames: [],
      liguistLanguageId: 278,
      name: "Parrot",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pasm"
      ],
      fileNames: [],
      group: "Parrot",
      liguistLanguageId: 279,
      name: "Parrot Assembly",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pir"
      ],
      fileNames: [],
      group: "Parrot",
      liguistLanguageId: 280,
      name: "Parrot Internal Representation",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.parrot.pir",
      vscodeLanguages: []
    },
    {
      aceMode: "pascal",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-pascal",
      codeMirrorMode: "pascal",
      extensions: [
        ".dfm",
        ".dpr",
        ".inc",
        ".lpr",
        ".pas",
        ".pascal",
        ".pp"
      ],
      fileNames: [],
      liguistLanguageId: 281,
      name: "Pascal",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pep"
      ],
      fileNames: [],
      liguistLanguageId: 840372442,
      name: "Pep8",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pep8",
      vscodeLanguages: []
    },
    {
      aceMode: "perl",
      aliases: [],
      atomGrammars: [
        "Perl",
        "Perl 6"
      ],
      codeMirrorMimeType: "text/x-perl",
      codeMirrorMode: "perl",
      extensions: [
        ".PL",
        ".al",
        ".cgi",
        ".fcgi",
        ".perl",
        ".ph",
        ".pl",
        ".plx",
        ".pm",
        ".pod",
        ".psgi",
        ".t"
      ],
      fileNames: [
        "cpanfile"
      ],
      liguistLanguageId: 282,
      name: "Perl",
      namespace: "perl",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.perl",
      vscodeLanguages: [
        "perl",
        "perl6"
      ]
    },
    {
      aceMode: "perl",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-perl",
      codeMirrorMode: "perl",
      extensions: [
        ".6pl",
        ".6pm",
        ".nqp",
        ".p6",
        ".p6l",
        ".p6m",
        ".pl",
        ".pl6",
        ".pm",
        ".pm6",
        ".t"
      ],
      fileNames: [
        "Rexfile"
      ],
      liguistLanguageId: 283,
      name: "Perl 6",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.perl6fe",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/troff",
      codeMirrorMode: "troff",
      extensions: [
        ".chem",
        ".pic"
      ],
      fileNames: [],
      group: "Roff",
      liguistLanguageId: 425,
      name: "Pic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pic",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pkl"
      ],
      fileNames: [],
      liguistLanguageId: 284,
      name: "Pickle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".l"
      ],
      fileNames: [],
      liguistLanguageId: 285,
      name: "PicoLisp",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pig"
      ],
      fileNames: [],
      liguistLanguageId: 286,
      name: "PigLatin",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pig_latin",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pike",
        ".pmod"
      ],
      fileNames: [],
      liguistLanguageId: 287,
      name: "Pike",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "perl",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-perl",
      codeMirrorMode: "perl",
      extensions: [
        ".pod"
      ],
      fileNames: [],
      liguistLanguageId: 288,
      name: "Pod",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pogo"
      ],
      fileNames: [],
      liguistLanguageId: 289,
      name: "PogoScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pogoscript",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pony"
      ],
      fileNames: [],
      liguistLanguageId: 290,
      name: "Pony",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.pony",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pcss"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 262764437,
      name: "PostCSS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.postcss",
      vscodeLanguages: [
        "postcss"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".eps",
        ".pfa",
        ".ps"
      ],
      fileNames: [],
      liguistLanguageId: 291,
      name: "PostScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.postscript",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pbt",
        ".sra",
        ".sru",
        ".srw"
      ],
      fileNames: [],
      liguistLanguageId: 292,
      name: "PowerBuilder",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "powershell",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-powershell",
      codeMirrorMode: "powershell",
      extensions: [
        ".ps1",
        ".psd1",
        ".psm1"
      ],
      fileNames: [],
      liguistLanguageId: 293,
      name: "PowerShell",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "powershell"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pde"
      ],
      fileNames: [],
      liguistLanguageId: 294,
      name: "Processing",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "prolog",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pl",
        ".pro",
        ".prolog",
        ".yap"
      ],
      fileNames: [],
      liguistLanguageId: 295,
      name: "Prolog",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.prolog",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".spin"
      ],
      fileNames: [],
      liguistLanguageId: 296,
      name: "Propeller Spin",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.spin",
      vscodeLanguages: []
    },
    {
      aceMode: "protobuf",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-protobuf",
      codeMirrorMode: "protobuf",
      extensions: [
        ".proto"
      ],
      fileNames: [],
      liguistLanguageId: 297,
      name: "Protocol Buffer",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.protobuf",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/pgp",
      codeMirrorMode: "asciiarmor",
      extensions: [
        ".asc",
        ".pub"
      ],
      fileNames: [],
      liguistLanguageId: 298,
      name: "Public Key",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "jade",
      aliases: [],
      atomGrammars: [
        "Jade",
        "Pug"
      ],
      codeMirrorMimeType: "text/x-pug",
      codeMirrorMode: "pug",
      extensions: [
        ".jade",
        ".pug"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 179,
      name: "Pug",
      namespace: "pug",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.jade",
      vscodeLanguages: [
        "jade"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [
        "Puppet"
      ],
      codeMirrorMimeType: "text/x-puppet",
      codeMirrorMode: "puppet",
      extensions: [
        ".pp"
      ],
      fileNames: [
        "Modulefile"
      ],
      liguistLanguageId: 299,
      name: "Puppet",
      namespace: "puppet",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.puppet",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pd"
      ],
      fileNames: [],
      liguistLanguageId: 300,
      name: "Pure Data",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pb",
        ".pbi"
      ],
      fileNames: [],
      liguistLanguageId: 301,
      name: "PureBasic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "haskell",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-haskell",
      codeMirrorMode: "haskell",
      extensions: [
        ".purs"
      ],
      fileNames: [],
      liguistLanguageId: 302,
      name: "PureScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.purescript",
      vscodeLanguages: []
    },
    {
      aceMode: "python",
      aliases: [],
      atomGrammars: [
        "Python"
      ],
      codeMirrorMimeType: "text/x-python",
      codeMirrorMode: "python",
      extensions: [
        ".bzl",
        ".cgi",
        ".fcgi",
        ".gyp",
        ".gypi",
        ".lmi",
        ".py",
        ".py3",
        ".pyde",
        ".pyi",
        ".pyp",
        ".pyt",
        ".pyw",
        ".rpy",
        ".spec",
        ".tac",
        ".wsgi",
        ".xpy"
      ],
      fileNames: [
        ".gclient",
        "BUCK",
        "BUILD",
        "BUILD.bazel",
        "SConscript",
        "SConstruct",
        "Snakefile",
        "WORKSPACE",
        "wscript"
      ],
      liguistLanguageId: 303,
      name: "Python",
      namespace: "python",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "python"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 428,
      name: "Python console",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.python.console",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pytb"
      ],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 304,
      name: "Python traceback",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.python.traceback",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".qbs",
        ".qml"
      ],
      fileNames: [],
      liguistLanguageId: 305,
      name: "QML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.qml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pri",
        ".pro"
      ],
      fileNames: [],
      liguistLanguageId: 306,
      name: "QMake",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "r",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-rsrc",
      codeMirrorMode: "r",
      extensions: [
        ".r",
        ".rd",
        ".rsx"
      ],
      fileNames: [
        ".Rprofile"
      ],
      liguistLanguageId: 307,
      name: "R",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "r"
      ]
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".raml"
      ],
      fileNames: [],
      liguistLanguageId: 308,
      name: "RAML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yaml",
      vscodeLanguages: []
    },
    {
      aceMode: "rdoc",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rdoc"
      ],
      fileNames: [],
      liguistLanguageId: 309,
      name: "RDoc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.rdoc",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rbbas",
        ".rbfrm",
        ".rbmnu",
        ".rbres",
        ".rbtbar",
        ".rbuistate"
      ],
      fileNames: [],
      liguistLanguageId: 310,
      name: "REALbasic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.vbnet",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pprx",
        ".rex",
        ".rexx"
      ],
      fileNames: [],
      liguistLanguageId: 311,
      name: "REXX",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.rexx",
      vscodeLanguages: []
    },
    {
      aceMode: "rhtml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/x-erb",
      codeMirrorMode: "htmlembedded",
      extensions: [
        ".rhtml"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 312,
      name: "RHTML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.erb",
      vscodeLanguages: []
    },
    {
      aceMode: "markdown",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-gfm",
      codeMirrorMode: "gfm",
      extensions: [
        ".rmd"
      ],
      fileNames: [],
      liguistLanguageId: 313,
      name: "RMarkdown",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.gfm",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".x"
      ],
      fileNames: [],
      liguistLanguageId: 1031374237,
      name: "RPC",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-rpm-spec",
      codeMirrorMode: "rpm",
      extensions: [
        ".spec"
      ],
      fileNames: [],
      liguistLanguageId: 314,
      name: "RPM Spec",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.rpm-spec",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rnh",
        ".rno"
      ],
      fileNames: [],
      liguistLanguageId: 315,
      name: "RUNOFF",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.runoff",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rkt",
        ".rktd",
        ".rktl",
        ".scrbl"
      ],
      fileNames: [],
      liguistLanguageId: 316,
      name: "Racket",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.racket",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rl"
      ],
      fileNames: [],
      liguistLanguageId: 317,
      name: "Ragel",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rsc"
      ],
      fileNames: [],
      liguistLanguageId: 173616037,
      name: "Rascal",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.rascal",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".raw"
      ],
      fileNames: [],
      liguistLanguageId: 318,
      name: "Raw token data",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "rust",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-rustsrc",
      codeMirrorMode: "rust",
      extensions: [
        ".re",
        ".rei"
      ],
      fileNames: [],
      group: "OCaml",
      liguistLanguageId: 869538413,
      name: "Reason",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.reason",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".r",
        ".r2",
        ".r3",
        ".reb",
        ".rebol"
      ],
      fileNames: [],
      liguistLanguageId: 319,
      name: "Rebol",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.rebol",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".red",
        ".reds"
      ],
      fileNames: [],
      liguistLanguageId: 320,
      name: "Red",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.red",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".cw"
      ],
      fileNames: [],
      liguistLanguageId: 321,
      name: "Redcode",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".regex",
        ".regexp"
      ],
      fileNames: [],
      liguistLanguageId: 363378884,
      name: "Regular Expression",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.regexp",
      vscodeLanguages: []
    },
    {
      aceMode: "python",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rpy"
      ],
      fileNames: [],
      liguistLanguageId: 322,
      name: "Ren'Py",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.renpy",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".rs",
        ".rsh"
      ],
      fileNames: [],
      liguistLanguageId: 323,
      name: "RenderScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ring"
      ],
      fileNames: [],
      liguistLanguageId: 431,
      name: "Ring",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ring",
      vscodeLanguages: []
    },
    {
      atomGrammars: [
        "Riot.js",
        "HTML (Riot Tag)"
      ],
      extensions: [
        ".tag"
      ],
      name: "Riot",
      namespace: "riot",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".robot"
      ],
      fileNames: [],
      liguistLanguageId: 324,
      name: "RobotFramework",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.robot",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/troff",
      codeMirrorMode: "troff",
      extensions: [
        ".1",
        ".1in",
        ".1m",
        ".1x",
        ".2",
        ".3",
        ".3in",
        ".3m",
        ".3qt",
        ".3x",
        ".4",
        ".5",
        ".6",
        ".7",
        ".8",
        ".9",
        ".l",
        ".man",
        ".me",
        ".ms",
        ".n",
        ".nr",
        ".rno",
        ".roff",
        ".tmac"
      ],
      fileNames: [
        "mmn",
        "mmt"
      ],
      liguistLanguageId: 141,
      name: "Roff",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.roff",
      vscodeLanguages: []
    },
    {
      aceMode: "clojure",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-clojure",
      codeMirrorMode: "clojure",
      extensions: [
        ".rg"
      ],
      fileNames: [],
      liguistLanguageId: 325,
      name: "Rouge",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clojure",
      vscodeLanguages: []
    },
    {
      aceMode: "ruby",
      aliases: [],
      atomGrammars: [
        "Ruby",
        "Ruby on Rails"
      ],
      codeMirrorMimeType: "text/x-ruby",
      codeMirrorMode: "ruby",
      extensions: [
        ".builder",
        ".eye",
        ".fcgi",
        ".gemspec",
        ".god",
        ".jbuilder",
        ".mspec",
        ".pluginspec",
        ".podspec",
        ".rabl",
        ".rake",
        ".rb",
        ".rbuild",
        ".rbw",
        ".rbx",
        ".ru",
        ".ruby",
        ".spec",
        ".thor",
        ".watchr"
      ],
      fileNames: [
        ".irbrc",
        ".pryrc",
        "Appraisals",
        "Berksfile",
        "Brewfile",
        "Buildfile",
        "Dangerfile",
        "Deliverfile",
        "Fastfile",
        "Gemfile",
        "Gemfile.lock",
        "Guardfile",
        "Jarfile",
        "Mavenfile",
        "Podfile",
        "Puppetfile",
        "Rakefile",
        "Snapfile",
        "Thorfile",
        "Vagrantfile",
        "buildfile"
      ],
      liguistLanguageId: 326,
      name: "Ruby",
      namespace: "ruby",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "ruby"
      ]
    },
    {
      aceMode: "rust",
      aliases: [],
      atomGrammars: [
        "Rust"
      ],
      codeMirrorMimeType: "text/x-rustsrc",
      codeMirrorMode: "rust",
      extensions: [
        ".rlib",
        ".rs",
        ".rs.in"
      ],
      fileNames: [],
      liguistLanguageId: 327,
      name: "Rust",
      namespace: "rust",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "rust"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sas",
      codeMirrorMode: "sas",
      extensions: [
        ".sas"
      ],
      fileNames: [],
      liguistLanguageId: 328,
      name: "SAS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sas",
      vscodeLanguages: []
    },
    {
      aceMode: "scss",
      aliases: [],
      atomGrammars: [
        "SCSS"
      ],
      codeMirrorMimeType: "text/x-scss",
      codeMirrorMode: "css",
      extensions: [
        ".scss"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 329,
      name: "SCSS",
      namespace: "scss",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.scss",
      vscodeLanguages: [
        "scss"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".smt",
        ".smt2"
      ],
      fileNames: [],
      liguistLanguageId: 330,
      name: "SMT",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.smt",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/sparql-query",
      codeMirrorMode: "sparql",
      extensions: [
        ".rq",
        ".sparql"
      ],
      fileNames: [],
      liguistLanguageId: 331,
      name: "SPARQL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sparql",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".hqf",
        ".sqf"
      ],
      fileNames: [],
      liguistLanguageId: 332,
      name: "SQF",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sqf",
      vscodeLanguages: []
    },
    {
      aceMode: "sql",
      aliases: [],
      atomGrammars: [
        "SQL",
        "SQL (Rails)"
      ],
      codeMirrorMimeType: "text/x-sql",
      codeMirrorMode: "sql",
      extensions: [
        ".cql",
        ".ddl",
        ".inc",
        ".mysql",
        ".prc",
        ".sql",
        ".tab",
        ".udf",
        ".viw"
      ],
      fileNames: [],
      liguistLanguageId: 333,
      name: "SQL",
      namespace: "sql",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sql",
      vscodeLanguages: [
        "sql"
      ]
    },
    {
      aceMode: "sql",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sql",
      codeMirrorMode: "sql",
      extensions: [
        ".db2",
        ".sql"
      ],
      fileNames: [],
      liguistLanguageId: 334,
      name: "SQLPL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sql",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".srt"
      ],
      fileNames: [],
      liguistLanguageId: 335,
      name: "SRecode Template",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.lisp",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ston"
      ],
      fileNames: [],
      group: "Smalltalk",
      liguistLanguageId: 336,
      name: "STON",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.smalltalk",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [
        "SVG"
      ],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".svg"
      ],
      fileNames: [],
      liguistLanguageId: 337,
      name: "SVG",
      namespace: "svg",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "python",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-python",
      codeMirrorMode: "python",
      extensions: [
        ".sage",
        ".sagews"
      ],
      fileNames: [],
      group: "Python",
      liguistLanguageId: 338,
      name: "Sage",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.python",
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".sls"
      ],
      fileNames: [],
      liguistLanguageId: 339,
      name: "SaltStack",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yaml.salt",
      vscodeLanguages: []
    },
    {
      aceMode: "sass",
      aliases: [],
      atomGrammars: [
        "Sass"
      ],
      codeMirrorMimeType: "text/x-sass",
      codeMirrorMode: "sass",
      extensions: [
        ".sass"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 340,
      name: "Sass",
      namespace: "sass",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sass",
      vscodeLanguages: [
        "scss",
        "sass"
      ]
    },
    {
      aceMode: "scala",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-scala",
      codeMirrorMode: "clike",
      extensions: [
        ".kojo",
        ".sbt",
        ".sc",
        ".scala"
      ],
      fileNames: [],
      liguistLanguageId: 341,
      name: "Scala",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".scaml"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 342,
      name: "Scaml",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.scaml",
      vscodeLanguages: []
    },
    {
      aceMode: "scheme",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-scheme",
      codeMirrorMode: "scheme",
      extensions: [
        ".sch",
        ".scm",
        ".sld",
        ".sls",
        ".sps",
        ".ss"
      ],
      fileNames: [],
      liguistLanguageId: 343,
      name: "Scheme",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sce",
        ".sci",
        ".tst"
      ],
      fileNames: [],
      liguistLanguageId: 344,
      name: "Scilab",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".self"
      ],
      fileNames: [],
      liguistLanguageId: 345,
      name: "Self",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".shader"
      ],
      fileNames: [],
      liguistLanguageId: 664257356,
      name: "ShaderLab",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shaderlab",
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [
        ".bash",
        ".bats",
        ".cgi",
        ".command",
        ".fcgi",
        ".ksh",
        ".sh",
        ".sh.in",
        ".tmux",
        ".tool",
        ".zsh"
      ],
      fileNames: [
        ".bash_history",
        ".bash_logout",
        ".bash_profile",
        ".bashrc",
        "PKGBUILD",
        "gradlew"
      ],
      liguistLanguageId: 346,
      name: "Shell",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "shellscript"
      ]
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [
        ".sh-session"
      ],
      fileNames: [],
      liguistLanguageId: 347,
      name: "ShellSession",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.shell-session",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".shen"
      ],
      fileNames: [],
      liguistLanguageId: 348,
      name: "Shen",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shen",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sl"
      ],
      fileNames: [],
      liguistLanguageId: 349,
      name: "Slash",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.slash",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-slim",
      codeMirrorMode: "slim",
      extensions: [
        ".slim"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 350,
      name: "Slim",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.slim",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".smali"
      ],
      fileNames: [],
      liguistLanguageId: 351,
      name: "Smali",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.smali",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-stsrc",
      codeMirrorMode: "smalltalk",
      extensions: [
        ".cs",
        ".st"
      ],
      fileNames: [],
      liguistLanguageId: 352,
      name: "Smalltalk",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "smarty",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-smarty",
      codeMirrorMode: "smarty",
      extensions: [
        ".tpl"
      ],
      fileNames: [],
      liguistLanguageId: 353,
      name: "Smarty",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.smarty",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [],
      fileNames: [],
      liguistLanguageId: 237469032,
      name: "Solidity",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.solidity",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".inc",
        ".sma",
        ".sp"
      ],
      fileNames: [],
      liguistLanguageId: 354,
      name: "SourcePawn",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.sp",
      vscodeLanguages: []
    },
    {
      atomGrammars: [
        "Spacebars"
      ],
      extensions: [],
      name: "Spacebars",
      namespace: "spacebars",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sfd"
      ],
      fileNames: [],
      liguistLanguageId: 767169629,
      name: "Spline Font Database",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.sfd",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-c++src",
      codeMirrorMode: "clike",
      extensions: [
        ".nut"
      ],
      fileNames: [],
      liguistLanguageId: 355,
      name: "Squirrel",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c++",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".stan"
      ],
      fileNames: [],
      liguistLanguageId: 356,
      name: "Stan",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.stan",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-ocaml",
      codeMirrorMode: "mllike",
      extensions: [
        ".ML",
        ".fun",
        ".sig",
        ".sml"
      ],
      fileNames: [],
      liguistLanguageId: 357,
      name: "Standard ML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ado",
        ".do",
        ".doh",
        ".ihlp",
        ".mata",
        ".matah",
        ".sthlp"
      ],
      fileNames: [],
      liguistLanguageId: 358,
      name: "Stata",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "stylus",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".styl"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 359,
      name: "Stylus",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.stylus",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".srt"
      ],
      fileNames: [],
      liguistLanguageId: 360,
      name: "SubRip Text",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.srt",
      vscodeLanguages: []
    },
    {
      aceMode: "javascript",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/javascript",
      codeMirrorMode: "javascript",
      extensions: [
        ".sublime-build",
        ".sublime-commands",
        ".sublime-completions",
        ".sublime-keymap",
        ".sublime-macro",
        ".sublime-menu",
        ".sublime-mousemap",
        ".sublime-project",
        ".sublime-settings",
        ".sublime-theme",
        ".sublime-workspace",
        ".sublime_metrics",
        ".sublime_session"
      ],
      fileNames: [],
      group: "JSON",
      liguistLanguageId: 423,
      name: "Sublime Text Config",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.js",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sss"
      ],
      fileNames: [],
      group: "CSS",
      liguistLanguageId: 826404698,
      name: "SugarSS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.css.postcss.sugarss",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".sc",
        ".scd"
      ],
      fileNames: [],
      liguistLanguageId: 361,
      name: "SuperCollider",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.supercollider",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-swift",
      codeMirrorMode: "swift",
      extensions: [
        ".swift"
      ],
      fileNames: [],
      liguistLanguageId: 362,
      name: "Swift",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "swift"
      ]
    },
    {
      atomGrammars: [
        "HTML (Swig)",
        "SWIG"
      ],
      extensions: [
        ".swig"
      ],
      name: "Swig",
      namespace: "swig",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "verilog",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-systemverilog",
      codeMirrorMode: "verilog",
      extensions: [
        ".sv",
        ".svh",
        ".vh"
      ],
      fileNames: [],
      liguistLanguageId: 363,
      name: "SystemVerilog",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".8xk",
        ".8xk.txt",
        ".8xp",
        ".8xp.txt"
      ],
      fileNames: [],
      liguistLanguageId: 422,
      name: "TI Program",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".tla"
      ],
      fileNames: [],
      liguistLanguageId: 364,
      name: "TLA",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.tla",
      vscodeLanguages: []
    },
    {
      aceMode: "toml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-toml",
      codeMirrorMode: "toml",
      extensions: [
        ".toml"
      ],
      fileNames: [],
      liguistLanguageId: 365,
      name: "TOML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.toml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".txl"
      ],
      fileNames: [],
      liguistLanguageId: 366,
      name: "TXL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.txl",
      vscodeLanguages: []
    },
    {
      aceMode: "tcl",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-tcl",
      codeMirrorMode: "tcl",
      extensions: [
        ".adp",
        ".tcl",
        ".tm"
      ],
      fileNames: [],
      liguistLanguageId: 367,
      name: "Tcl",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "sh",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-sh",
      codeMirrorMode: "shell",
      extensions: [
        ".csh",
        ".tcsh"
      ],
      fileNames: [],
      group: "Shell",
      liguistLanguageId: 368,
      name: "Tcsh",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.shell",
      vscodeLanguages: []
    },
    {
      aceMode: "tex",
      aliases: [],
      atomGrammars: [
        "LaTeX"
      ],
      codeMirrorMimeType: "text/x-stex",
      codeMirrorMode: "stex",
      extensions: [
        ".aux",
        ".bbx",
        ".bib",
        ".cbx",
        ".cls",
        ".dtx",
        ".ins",
        ".lbx",
        ".ltx",
        ".mkii",
        ".mkiv",
        ".mkvi",
        ".sty",
        ".tex",
        ".toc"
      ],
      fileNames: [],
      liguistLanguageId: 369,
      name: "TeX",
      namespace: "latex",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "latex",
        "tex"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".tea"
      ],
      fileNames: [],
      liguistLanguageId: 370,
      name: "Tea",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.tea",
      vscodeLanguages: []
    },
    {
      aceMode: "lua",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-lua",
      codeMirrorMode: "lua",
      extensions: [
        ".t"
      ],
      fileNames: [],
      liguistLanguageId: 371,
      name: "Terra",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fr",
        ".nb",
        ".ncl",
        ".no",
        ".txt"
      ],
      fileNames: [
        "COPYING",
        "COPYRIGHT.regex",
        "FONTLOG",
        "INSTALL",
        "INSTALL.mysql",
        "LICENSE",
        "LICENSE.mysql",
        "NEWS",
        "README.1ST",
        "README.me",
        "README.mysql",
        "click.me",
        "delete.me",
        "keep.me",
        "read.me",
        "test.me"
      ],
      liguistLanguageId: 372,
      name: "Text",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "textile",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-textile",
      codeMirrorMode: "textile",
      extensions: [
        ".textile"
      ],
      fileNames: [],
      liguistLanguageId: 373,
      name: "Textile",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".thrift"
      ],
      fileNames: [],
      liguistLanguageId: 374,
      name: "Thrift",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.thrift",
      vscodeLanguages: []
    },
    {
      atomGrammars: [
        "TSS"
      ],
      extensions: [
        ".tss"
      ],
      name: "Titanium Style Sheets",
      namespace: "tss",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".t",
        ".tu"
      ],
      fileNames: [],
      liguistLanguageId: 375,
      name: "Turing",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.turing",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/turtle",
      codeMirrorMode: "turtle",
      extensions: [
        ".ttl"
      ],
      fileNames: [],
      liguistLanguageId: 376,
      name: "Turtle",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.turtle",
      vscodeLanguages: []
    },
    {
      aceMode: "twig",
      aliases: [],
      atomGrammars: [
        "HTML (Twig)"
      ],
      codeMirrorMimeType: "text/x-twig",
      codeMirrorMode: "twig",
      extensions: [
        ".twig"
      ],
      fileNames: [],
      group: "HTML",
      liguistLanguageId: 377,
      name: "Twig",
      namespace: "twig",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.twig",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".tl"
      ],
      fileNames: [],
      liguistLanguageId: 632765617,
      name: "Type Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.tl",
      vscodeLanguages: []
    },
    {
      aceMode: "typescript",
      aliases: [],
      atomGrammars: [
        "TypeScript"
      ],
      codeMirrorMimeType: "application/typescript",
      codeMirrorMode: "javascript",
      extensions: [
        ".ts",
        ".tsx"
      ],
      fileNames: [],
      liguistLanguageId: 378,
      name: "TypeScript",
      namespace: "typescript",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ts",
      vscodeLanguages: [
        "typescript",
        "typescriptreact"
      ]
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".upc"
      ],
      fileNames: [],
      group: "C",
      liguistLanguageId: 379,
      name: "Unified Parallel C",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".anim",
        ".asset",
        ".mat",
        ".meta",
        ".prefab",
        ".unity"
      ],
      fileNames: [],
      liguistLanguageId: 380,
      name: "Unity3D Asset",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yaml",
      vscodeLanguages: []
    },
    {
      aceMode: "assembly_x86",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ms",
        ".s"
      ],
      fileNames: [],
      group: "Assembly",
      liguistLanguageId: 120,
      name: "Unix Assembly",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.assembly",
      vscodeLanguages: []
    },
    {
      aceMode: "csharp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csharp",
      codeMirrorMode: "clike",
      extensions: [
        ".uno"
      ],
      fileNames: [],
      liguistLanguageId: 381,
      name: "Uno",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.cs",
      vscodeLanguages: []
    },
    {
      aceMode: "java",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-java",
      codeMirrorMode: "clike",
      extensions: [
        ".uc"
      ],
      fileNames: [],
      liguistLanguageId: 382,
      name: "UnrealScript",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.java",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ur",
        ".urs"
      ],
      fileNames: [],
      liguistLanguageId: 383,
      name: "UrWeb",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.ur",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".vcl"
      ],
      fileNames: [],
      liguistLanguageId: 384,
      name: "VCL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.varnish.vcl",
      vscodeLanguages: []
    },
    {
      aceMode: "vhdl",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-vhdl",
      codeMirrorMode: "vhdl",
      extensions: [
        ".vhd",
        ".vhdl",
        ".vhf",
        ".vhi",
        ".vho",
        ".vhs",
        ".vht",
        ".vhw"
      ],
      fileNames: [],
      liguistLanguageId: 385,
      name: "VHDL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "vala",
      aliases: [],
      atomGrammars: [
        "Vala"
      ],
      extensions: [
        ".vala",
        ".vapi"
      ],
      fileNames: [],
      liguistLanguageId: 386,
      name: "Vala",
      namespace: "vala",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "verilog",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-verilog",
      codeMirrorMode: "verilog",
      extensions: [
        ".v",
        ".veo"
      ],
      fileNames: [],
      liguistLanguageId: 387,
      name: "Verilog",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".vim"
      ],
      fileNames: [
        ".nvimrc",
        ".vimrc",
        "_vimrc",
        "gvimrc",
        "nvimrc",
        "vimrc"
      ],
      liguistLanguageId: 388,
      name: "Vim script",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.viml",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-vb",
      codeMirrorMode: "vb",
      extensions: [
        ".bas",
        ".cls",
        ".frm",
        ".frx",
        ".vb",
        ".vba",
        ".vbhtml",
        ".vbs"
      ],
      fileNames: [],
      liguistLanguageId: 389,
      name: "Visual Basic",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.vbnet",
      vscodeLanguages: [
        "vb"
      ]
    },
    {
      atomGrammars: [
        "Visualforce"
      ],
      extensions: [
        ".page"
      ],
      name: "Visualforce",
      namespace: "visualforce",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "d",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-d",
      codeMirrorMode: "d",
      extensions: [
        ".volt"
      ],
      fileNames: [],
      liguistLanguageId: 390,
      name: "Volt",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.d",
      vscodeLanguages: []
    },
    {
      aceMode: "html",
      aliases: [],
      atomGrammars: [
        "Vue Component"
      ],
      extensions: [
        ".vue"
      ],
      fileNames: [],
      liguistLanguageId: 391,
      name: "Vue",
      namespace: "vue",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.html.vue",
      vscodeLanguages: [
        "vue"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mtl"
      ],
      fileNames: [],
      liguistLanguageId: 392,
      name: "Wavefront Material",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.wavefront.mtl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".obj"
      ],
      fileNames: [],
      liguistLanguageId: 393,
      name: "Wavefront Object",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.wavefront.obj",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".owl"
      ],
      fileNames: [],
      liguistLanguageId: 394,
      name: "Web Ontology Language",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "lisp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-common-lisp",
      codeMirrorMode: "commonlisp",
      extensions: [
        ".wast",
        ".wat"
      ],
      fileNames: [],
      liguistLanguageId: 956556503,
      name: "WebAssembly",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.webassembly",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-webidl",
      codeMirrorMode: "webidl",
      extensions: [
        ".webidl"
      ],
      fileNames: [],
      liguistLanguageId: 395,
      name: "WebIDL",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.webidl",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".toc"
      ],
      fileNames: [],
      liguistLanguageId: 396,
      name: "World of Warcraft Addon Data",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.toc",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".x10"
      ],
      fileNames: [],
      liguistLanguageId: 397,
      name: "X10",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.x10",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".xc"
      ],
      fileNames: [],
      liguistLanguageId: 398,
      name: "XC",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.xc",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [],
      fileNames: [
        ".XCompose",
        "XCompose",
        "xcompose"
      ],
      liguistLanguageId: 225167241,
      name: "XCompose",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "config.xcompose",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [
        "GSP",
        "JSP",
        "SLD",
        "XHTML",
        "XML",
        "XSD",
        "XSL"
      ],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".adml",
        ".admx",
        ".ant",
        ".axml",
        ".builds",
        ".ccproj",
        ".ccxml",
        ".clixml",
        ".cproject",
        ".cscfg",
        ".csdef",
        ".csl",
        ".csproj",
        ".ct",
        ".depproj",
        ".dita",
        ".ditamap",
        ".ditaval",
        ".dll.config",
        ".dotsettings",
        ".filters",
        ".fsproj",
        ".fxml",
        ".glade",
        ".gml",
        ".grxml",
        ".gsp",
        ".iml",
        ".ivy",
        ".jelly",
        ".jsp",
        ".jsproj",
        ".kml",
        ".launch",
        ".mdpolicy",
        ".mjml",
        ".mm",
        ".mod",
        ".mxml",
        ".natvis",
        ".ndproj",
        ".nproj",
        ".nuspec",
        ".odd",
        ".osm",
        ".pkgproj",
        ".plist",
        ".pluginspec",
        ".proj",
        ".props",
        ".ps1xml",
        ".psc1",
        ".pt",
        ".rdf",
        ".resx",
        ".rss",
        ".sch",
        ".scxml",
        ".sfproj",
        ".shproj",
        ".sld",
        ".srdf",
        ".stTheme",
        ".storyboard",
        ".sublime-snippet",
        ".targets",
        ".tmCommand",
        ".tmLanguage",
        ".tmPreferences",
        ".tmSnippet",
        ".tmTheme",
        ".tml",
        ".ts",
        ".tsx",
        ".ui",
        ".urdf",
        ".ux",
        ".vbproj",
        ".vcxproj",
        ".vsixmanifest",
        ".vssettings",
        ".vstemplate",
        ".vxml",
        ".wixproj",
        ".wsdl",
        ".wsf",
        ".wxi",
        ".wxl",
        ".wxs",
        ".x3d",
        ".xacro",
        ".xaml",
        ".xhtml",
        ".xib",
        ".xlf",
        ".xliff",
        ".xmi",
        ".xml",
        ".xml.dist",
        ".xproj",
        ".xsd",
        ".xsl",
        ".xspec",
        ".xul",
        ".zcml"
      ],
      fileNames: [
        ".classpath",
        ".project",
        "App.config",
        "NuGet.config",
        "Settings.StyleCop",
        "Web.Debug.config",
        "Web.Release.config",
        "Web.config",
        "packages.config"
      ],
      liguistLanguageId: 399,
      name: "XML",
      namespace: "xml",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: [
        "xml"
      ]
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".pm",
        ".xpm"
      ],
      fileNames: [],
      liguistLanguageId: 781846279,
      name: "XPM",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".xsp-config",
        ".xsp.metadata"
      ],
      fileNames: [],
      liguistLanguageId: 400,
      name: "XPages",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".xpl",
        ".xproc"
      ],
      fileNames: [],
      liguistLanguageId: 401,
      name: "XProc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml",
      vscodeLanguages: []
    },
    {
      aceMode: "xquery",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "application/xquery",
      codeMirrorMode: "xquery",
      extensions: [
        ".xq",
        ".xql",
        ".xqm",
        ".xquery",
        ".xqy"
      ],
      fileNames: [],
      liguistLanguageId: 402,
      name: "XQuery",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.xq",
      vscodeLanguages: []
    },
    {
      aceMode: "c_cpp",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-csrc",
      codeMirrorMode: "clike",
      extensions: [
        ".xs"
      ],
      fileNames: [],
      liguistLanguageId: 403,
      name: "XS",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c",
      vscodeLanguages: []
    },
    {
      aceMode: "xml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/xml",
      codeMirrorMode: "xml",
      extensions: [
        ".xsl",
        ".xslt"
      ],
      fileNames: [],
      liguistLanguageId: 404,
      name: "XSLT",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "text.xml.xsl",
      vscodeLanguages: [
        "xsl"
      ]
    },
    {
      atomGrammars: [
        "XTemplate"
      ],
      extensions: [
        ".xtemplate"
      ],
      name: "XTemplate",
      namespace: "xtemplate",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".xojo_code",
        ".xojo_menu",
        ".xojo_report",
        ".xojo_script",
        ".xojo_toolbar",
        ".xojo_window"
      ],
      fileNames: [],
      liguistLanguageId: 405,
      name: "Xojo",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.vbnet",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".xtend"
      ],
      fileNames: [],
      liguistLanguageId: 406,
      name: "Xtend",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "yaml",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-yaml",
      codeMirrorMode: "yaml",
      extensions: [
        ".reek",
        ".rviz",
        ".sublime-syntax",
        ".syntax",
        ".yaml",
        ".yaml-tmlanguage",
        ".yml",
        ".yml.mysql"
      ],
      fileNames: [
        ".clang-format",
        ".clang-tidy"
      ],
      liguistLanguageId: 407,
      name: "YAML",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yaml",
      vscodeLanguages: [
        "yaml"
      ]
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".yang"
      ],
      fileNames: [],
      liguistLanguageId: 408,
      name: "YANG",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yang",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".yar",
        ".yara"
      ],
      fileNames: [],
      liguistLanguageId: 805122868,
      name: "YARA",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.yara",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".y",
        ".yacc",
        ".yy"
      ],
      fileNames: [],
      liguistLanguageId: 409,
      name: "Yacc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.bison",
      vscodeLanguages: []
    },
    {
      aceMode: "php",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".zep"
      ],
      fileNames: [],
      liguistLanguageId: 410,
      name: "Zephir",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.php.zephir",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".zimpl",
        ".zmpl",
        ".zpl"
      ],
      fileNames: [],
      liguistLanguageId: 411,
      name: "Zimpl",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "none",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".desktop",
        ".desktop.in"
      ],
      fileNames: [],
      liguistLanguageId: 412,
      name: "desktop",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.desktop",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ec",
        ".eh"
      ],
      fileNames: [],
      liguistLanguageId: 413,
      name: "eC",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.c.ec",
      vscodeLanguages: []
    },
    {
      aceMode: "clojure",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-clojure",
      codeMirrorMode: "clojure",
      extensions: [
        ".edn"
      ],
      fileNames: [],
      liguistLanguageId: 414,
      name: "edn",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clojure",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".fish"
      ],
      fileNames: [],
      group: "Shell",
      liguistLanguageId: 415,
      name: "fish",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.fish",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".mu"
      ],
      fileNames: [],
      liguistLanguageId: 416,
      name: "mupad",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".nc"
      ],
      fileNames: [],
      liguistLanguageId: 417,
      name: "nesC",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.nesc",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ooc"
      ],
      fileNames: [],
      liguistLanguageId: 418,
      name: "ooc",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-rst",
      codeMirrorMode: "rst",
      extensions: [
        ".rest",
        ".rest.txt",
        ".rst",
        ".rst.txt"
      ],
      fileNames: [],
      liguistLanguageId: 419,
      name: "reStructuredText",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".wdl"
      ],
      fileNames: [],
      liguistLanguageId: 374521672,
      name: "wdl",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.wdl",
      vscodeLanguages: []
    },
    {
      aceMode: "clojure",
      aliases: [],
      atomGrammars: [],
      codeMirrorMimeType: "text/x-clojure",
      codeMirrorMode: "clojure",
      extensions: [
        ".wisp"
      ],
      fileNames: [],
      liguistLanguageId: 420,
      name: "wisp",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.clojure",
      vscodeLanguages: []
    },
    {
      aceMode: "text",
      aliases: [],
      atomGrammars: [],
      extensions: [
        ".ch",
        ".prg",
        ".prw"
      ],
      fileNames: [],
      liguistLanguageId: 421,
      name: "xBase",
      namespace: "",
      since: "0.9.0",
      sublimeSyntaxes: [],
      textMateScope: "source.harbour",
      vscodeLanguages: []
    }
  ];
});

// node_modules/unibeautify/dist/src/languages.js
var require_languages2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Languages = require_languages();
});

// node_modules/unibeautify/dist/src/options.js
var require_options = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Options = {
    align_assignments: {
      default: false,
      description: "If lists of assignments or properties should be vertically aligned for faster and easier reading.",
      since: "0.7.0",
      type: "boolean"
    },
    arrow_parens: {
      default: "always",
      description: "Require parenthesis in arrow function arguments",
      enum: ["always", "as-needed"],
      since: "0.7.0",
      type: "string"
    },
    brace_style: {
      default: "collapse",
      description: "Brace style",
      enum: [
        "collapse",
        "collapse-preserve-inline",
        "expand",
        "end-expand",
        "none"
      ],
      since: "0.7.0",
      type: "string"
    },
    break_chained_methods: {
      default: false,
      description: "Break chained method calls across subsequent lines",
      since: "0.7.0",
      type: "boolean"
    },
    comma_first: {
      default: false,
      description: "Put commas at the beginning of new line instead of end",
      since: "0.7.0",
      type: "boolean"
    },
    end_of_line: {
      default: "System Default",
      description: "End-Of-Line (EOL) separator",
      enum: ["CRLF", "LF", "System Default"],
      since: "0.7.0",
      type: "string"
    },
    end_with_comma: {
      default: false,
      description: "If a terminating comma should be inserted into arrays, object literals, and destructured objects.",
      since: "0.7.0",
      type: "boolean"
    },
    end_with_newline: {
      default: false,
      description: "End output with newline",
      since: "0.7.0",
      type: "boolean"
    },
    end_with_semicolon: {
      default: false,
      description: "Insert a semicolon at the end of statements",
      since: "0.7.0",
      type: "boolean"
    },
    force_indentation: {
      default: false,
      description: "if indentation should be forcefully applied to markup even if it disruptively adds unintended whitespace to the documents rendered output",
      since: "0.7.0",
      type: "boolean"
    },
    identifier_case: {
      default: "lowercase",
      description: "Case type for identifiers",
      enum: ["lowercase", "uppercase", "capitalize"],
      since: "0.17.0",
      type: "string"
    },
    indent_chained_methods: {
      default: true,
      description: "Indent chained method calls",
      since: "0.10.0",
      type: "boolean"
    },
    indent_char: {
      default: " ",
      deprecated: "0.8.0",
      description: "Indentation character",
      enum: [" ", "	"],
      since: "0.7.0",
      type: "string"
    },
    indent_comments: {
      default: true,
      description: "Determines whether comments should be indented.",
      since: "0.7.0",
      type: "boolean"
    },
    indent_inner_html: {
      default: false,
      description: "Indent <head> and <body> sections.",
      since: "0.7.0",
      type: "boolean"
    },
    indent_level: {
      default: 0,
      description: "Initial indentation level",
      minimum: 0,
      multipleOf: 1,
      since: "0.7.0",
      type: "integer"
    },
    indent_scripts: {
      default: "normal",
      description: "Indent scripts",
      enum: ["keep", "separate", "normal"],
      since: "0.7.0",
      type: "string"
    },
    indent_size: {
      default: 2,
      description: "Indentation size/length",
      minimum: 0,
      multipleOf: 1,
      since: "0.7.0",
      type: "integer"
    },
    indent_style: {
      default: "space",
      description: "Indentation style",
      enum: ["space", "tab"],
      since: "0.8.0",
      type: "string"
    },
    indent_with_tabs: {
      default: true,
      deprecated: "0.8.0",
      description: "Indentation uses tabs, overrides `Indent Size` and `Indent Char`",
      since: "0.7.0",
      type: "boolean"
    },
    jslint_happy: {
      default: false,
      description: "Enable jslint-stricter mode",
      since: "0.7.0",
      title: "JSLint Happy",
      type: "boolean"
    },
    jsx_brackets: {
      default: false,
      description: "Put the `>` of a multi-line JSX element at the end of the last line",
      since: "0.7.0",
      title: "JSX Brackets",
      type: "boolean"
    },
    keep_array_indentation: {
      default: false,
      description: "Preserve array indentation",
      since: "0.7.0",
      type: "boolean"
    },
    keyword_case: {
      default: "lowercase",
      description: "Case type for keywords",
      enum: ["lowercase", "uppercase", "capitalize"],
      since: "0.17.0",
      type: "string"
    },
    max_preserve_newlines: {
      default: 10,
      description: "Number of line-breaks to be preserved in one chunk",
      multipleOf: 1,
      since: "0.7.0",
      type: "integer"
    },
    multiline_ternary: {
      default: "always",
      description: "Enforces new lines between the operands of a ternary expression",
      enum: ["always", "always-multiline", "never"],
      since: "0.7.0",
      type: "string"
    },
    newline_before_tags: {
      default: ["head", "body", "/html"],
      description: "List of tags which should have an extra newline before them.",
      items: {
        type: "string"
      },
      since: "0.7.0",
      type: "array"
    },
    newline_between_rules: {
      default: true,
      description: "Add a newline between CSS rules",
      since: "0.7.0",
      type: "boolean"
    },
    no_leading_zero: {
      default: false,
      description: "If in CSS values leading 0s immediately preceeding a decimal should be removed or prevented.",
      since: "0.7.0",
      type: "boolean"
    },
    object_curly_spacing: {
      default: true,
      description: "Inserts a space before/after brackets for object literals, destructuring assignments, and import/export specifiers",
      since: "0.7.0",
      type: "boolean"
    },
    pragma_insert: {
      default: false,
      description: "Insert a marker at the top of a file specifying the file has been beautified",
      since: "0.7.0",
      type: "boolean"
    },
    pragma_require: {
      default: false,
      description: "Restrict beautifying files to only those with a pragma at the top",
      since: "0.7.0",
      type: "boolean"
    },
    preserve_newlines: {
      default: true,
      description: "Preserve line-breaks",
      since: "0.7.0",
      type: "boolean"
    },
    quotes: {
      default: "none",
      description: "Convert the quote characters delimiting strings from either double or single quotes to the other.",
      enum: ["none", "double", "single"],
      since: "0.7.0",
      type: "string"
    },
    remove_trailing_whitespace: {
      default: false,
      description: "Remove trailing whitespace",
      since: "0.7.0",
      type: "boolean"
    },
    selector_separator_newline: {
      default: false,
      description: "Add a newline between multiple selectors",
      since: "0.7.0",
      type: "boolean"
    },
    space_after_anon_function: {
      default: false,
      description: "Add a space before an anonymous function's parentheses. ie. `function ()`",
      since: "0.7.0",
      type: "boolean"
    },
    space_before_conditional: {
      default: true,
      description: "Add a space before conditional, `if(true)` vs `if (true)`",
      since: "0.7.0",
      type: "boolean"
    },
    space_in_empty_paren: {
      default: false,
      description: "Add padding spaces within empty parentheses, ie. `f( )`",
      since: "0.7.0",
      type: "boolean"
    },
    space_in_paren: {
      default: false,
      description: "Add padding spaces within parentheses, ie. `f( a, b )`",
      since: "0.7.0",
      type: "boolean"
    },
    typesafe_equality_operators: {
      default: false,
      description: "Use typesafe equality operators (`===` and `!==` instead of `==` and `!=`)",
      since: "0.10.0",
      type: "boolean"
    },
    unescape_strings: {
      default: false,
      description: "Decode printable characters encoded in xNN notation",
      since: "0.7.0",
      type: "boolean"
    },
    unformatted: {
      default: [
        "a",
        "abbr",
        "area",
        "audio",
        "b",
        "bdi",
        "bdo",
        "br",
        "button",
        "canvas",
        "cite",
        "code",
        "data",
        "datalist",
        "del",
        "dfn",
        "em",
        "embed",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "map",
        "mark",
        "math",
        "meter",
        "noscript",
        "object",
        "output",
        "progress",
        "q",
        "ruby",
        "s",
        "samp",
        "select",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "svg",
        "template",
        "textarea",
        "time",
        "u",
        "var",
        "video",
        "wbr",
        "text",
        "acronym",
        "address",
        "big",
        "dt",
        "strike",
        "tt",
        "pre",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ],
      description: "List of tags (defaults to inline) that should not be reformatted",
      items: {
        type: "string"
      },
      since: "0.7.0",
      type: "array"
    },
    unindent_chained_methods: {
      default: false,
      deprecated: "0.10.0",
      description: "Do not indent chained method calls",
      since: "0.7.0",
      type: "boolean"
    },
    wrap_attributes: {
      default: "auto",
      description: "Wrap attributes to new lines",
      enum: ["auto", "force", "force-aligned"],
      since: "0.7.0",
      type: "string"
    },
    wrap_attributes_indent_size: {
      default: 4,
      description: "Indent wrapped attributes to after N characters",
      minimum: 0,
      multipleOf: 1,
      since: "0.7.0",
      type: "integer"
    },
    wrap_line_length: {
      default: 80,
      description: "Wrap lines at next opportunity after N characters",
      minimum: 0,
      multipleOf: 1,
      since: "0.7.0",
      type: "integer"
    },
    wrap_prose: {
      default: "preserve",
      description: "Wrap markdown text to new lines",
      enum: ["always", "never", "preserve"],
      since: "0.7.0",
      type: "string"
    }
  };
});

// node_modules/unibeautify/dist/src/index.js
var require_src = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  __export2(require_beautifier());
  __export2(require_languages2());
  __export2(require_options());
  __export2(require_DependencyManager2());
  __export2(require_LanguageManager());
  __export2(require_OptionsManager());
  var beautifier_1 = require_beautifier();
  var options_1 = require_options();
  var languages_1 = require_languages2();
  function newUnibeautify() {
    const unibeautify2 = new beautifier_1.Unibeautify();
    unibeautify2.loadOptions(options_1.Options);
    unibeautify2.loadLanguages(languages_1.Languages);
    return unibeautify2;
  }
  exports2.newUnibeautify = newUnibeautify;
  exports2.default = newUnibeautify();
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var fs5 = require("fs");
  module2.exports = (fp) => new Promise((resolve) => {
    fs5.access(fp, (err) => {
      resolve(!err);
    });
  });
  module2.exports.sync = (fp) => {
    try {
      fs5.accessSync(fp);
      return true;
    } catch (err) {
      return false;
    }
  };
});

// node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = require_p_try();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = (el, tester) => Promise.resolve(el).then(tester);
  var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
  module2.exports = (iterable, tester, opts) => {
    opts = Object.assign({
      concurrency: Infinity,
      preserveOrder: true
    }, opts);
    const limit = pLimit(opts.concurrency);
    const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
    const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
    return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
    }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
  };
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var pathExists = require_path_exists();
  var pLocate = require_p_locate();
  module2.exports = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    return pLocate(iterable, (el) => pathExists(path5.resolve(options.cwd, el)), options);
  };
  module2.exports.sync = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    for (const el of iterable) {
      if (pathExists.sync(path5.resolve(options.cwd, el))) {
        return el;
      }
    }
  };
});

// node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var locatePath = require_locate_path();
  module2.exports = (filename, opts = {}) => {
    const startDir = path5.resolve(opts.cwd || "");
    const {root} = path5.parse(startDir);
    const filenames = [].concat(filename);
    return new Promise((resolve) => {
      (function find(dir) {
        locatePath(filenames, {cwd: dir}).then((file) => {
          if (file) {
            resolve(path5.join(dir, file));
          } else if (dir === root) {
            resolve(null);
          } else {
            find(path5.dirname(dir));
          }
        });
      })(startDir);
    });
  };
  module2.exports.sync = (filename, opts = {}) => {
    let dir = path5.resolve(opts.cwd || "");
    const {root} = path5.parse(dir);
    const filenames = [].concat(filename);
    while (true) {
      const file = locatePath.sync(filenames, {cwd: dir});
      if (file) {
        return path5.join(dir, file);
      }
      if (dir === root) {
        return null;
      }
      dir = path5.dirname(dir);
    }
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module2.exports = patch;
  function patch(fs5) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs5);
    }
    if (!fs5.lutimes) {
      patchLutimes(fs5);
    }
    fs5.chown = chownFix(fs5.chown);
    fs5.fchown = chownFix(fs5.fchown);
    fs5.lchown = chownFix(fs5.lchown);
    fs5.chmod = chmodFix(fs5.chmod);
    fs5.fchmod = chmodFix(fs5.fchmod);
    fs5.lchmod = chmodFix(fs5.lchmod);
    fs5.chownSync = chownFixSync(fs5.chownSync);
    fs5.fchownSync = chownFixSync(fs5.fchownSync);
    fs5.lchownSync = chownFixSync(fs5.lchownSync);
    fs5.chmodSync = chmodFixSync(fs5.chmodSync);
    fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
    fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
    fs5.stat = statFix(fs5.stat);
    fs5.fstat = statFix(fs5.fstat);
    fs5.lstat = statFix(fs5.lstat);
    fs5.statSync = statFixSync(fs5.statSync);
    fs5.fstatSync = statFixSync(fs5.fstatSync);
    fs5.lstatSync = statFixSync(fs5.lstatSync);
    if (!fs5.lchmod) {
      fs5.lchmod = function(path5, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs5.lchmodSync = function() {
      };
    }
    if (!fs5.lchown) {
      fs5.lchown = function(path5, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs5.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs5.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs5.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs5.rename);
    }
    fs5.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs5.read);
    fs5.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs5, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs5.readSync);
    function patchLchmod(fs6) {
      fs6.lchmod = function(path5, mode, callback) {
        fs6.open(path5, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs6.fchmod(fd, mode, function(err2) {
            fs6.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs6.lchmodSync = function(path5, mode) {
        var fd = fs6.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs6.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs6.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs6.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs6) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs6.lutimes = function(path5, at, mt, cb) {
          fs6.open(path5, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs6.futimes(fd, at, mt, function(er2) {
              fs6.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs6.lutimesSync = function(path5, at, mt) {
          var fd = fs6.openSync(path5, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs6.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs6.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs6.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs5, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs5, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs5, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs5, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs5) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path5, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path5, options);
      Stream.call(this);
      var self2 = this;
      this.path = path5;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs5.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path5, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path5, options);
      Stream.call(this);
      this.path = path5;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs5.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = {__proto__: getPrototypeOf(obj)};
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util2 = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util2.debuglog)
    debug = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs5[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs5, queue);
    fs5.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs5, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs5.close);
    fs5.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs5, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs5.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs5[gracefulQueue]);
        require("assert").equal(fs5[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs5[gracefulQueue]);
  }
  module2.exports = patch(clone(fs5));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
    module2.exports = patch(fs5);
    fs5.__patched = true;
  }
  function patch(fs6) {
    polyfills(fs6);
    fs6.gracefulify = patch;
    fs6.createReadStream = createReadStream;
    fs6.createWriteStream = createWriteStream;
    var fs$readFile = fs6.readFile;
    fs6.readFile = readFile;
    function readFile(path5, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path5, options, cb);
      function go$readFile(path6, options2, cb2) {
        return fs$readFile(path6, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path6, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs6.writeFile;
    fs6.writeFile = writeFile;
    function writeFile(path5, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path5, data, options, cb);
      function go$writeFile(path6, data2, options2, cb2) {
        return fs$writeFile(path6, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path6, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs6.appendFile;
    if (fs$appendFile)
      fs6.appendFile = appendFile;
    function appendFile(path5, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path5, data, options, cb);
      function go$appendFile(path6, data2, options2, cb2) {
        return fs$appendFile(path6, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path6, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$copyFile = fs6.copyFile;
    if (fs$copyFile)
      fs6.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return fs$copyFile(src, dest, flags, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([fs$copyFile, [src, dest, flags, cb]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      });
    }
    var fs$readdir = fs6.readdir;
    fs6.readdir = readdir;
    function readdir(path5, options, cb) {
      var args = [path5];
      if (typeof options !== "function") {
        args.push(options);
      } else {
        cb = options;
      }
      args.push(go$readdir$cb);
      return go$readdir(args);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args) {
      return fs$readdir.apply(fs6, args);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs6);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs6.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs6.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs6, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs6, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs6, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs6, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path5, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path5, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path5, options) {
      return new fs6.ReadStream(path5, options);
    }
    function createWriteStream(path5, options) {
      return new fs6.WriteStream(path5, options);
    }
    var fs$open = fs6.open;
    fs6.open = open;
    function open(path5, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path5, flags, mode, cb);
      function go$open(path6, flags2, mode2, cb2) {
        return fs$open(path6, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path6, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs6;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs5[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs5[gracefulQueue].shift();
    if (elem) {
      debug("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
});

// node_modules/strip-bom/index.js
var require_strip_bom = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (x) => {
    if (typeof x !== "string") {
      throw new TypeError("Expected a string, got " + typeof x);
    }
    if (x.charCodeAt(0) === 65279) {
      return x.slice(1);
    }
    return x;
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isArrayish(obj) {
    if (!obj) {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
  };
});

// node_modules/error-ex/index.js
var require_error_ex = __commonJS((exports2, module2) => {
  "use strict";
  var util2 = require("util");
  var isArrayish = require_is_arrayish();
  var errorEx = function errorEx2(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }
      message = message instanceof Error ? message.message : message || this.message;
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, "message", {
        configurable: true,
        enumerable: false,
        get: function() {
          var newMessage = message.split(/\r?\n/g);
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("message" in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;
              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }
          return newMessage.join("\n");
        },
        set: function(v) {
          message = v;
        }
      });
      var overwrittenStack = null;
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;
      stackDescriptor.set = function(newstack) {
        overwrittenStack = newstack;
      };
      stackDescriptor.get = function() {
        var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
        if (!overwrittenStack) {
          stack[0] = this.name + ": " + this.message;
        }
        var lineCount = 1;
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ("line" in modifier) {
            var line = modifier.line(this[key]);
            if (line) {
              stack.splice(lineCount++, 0, "    " + line);
            }
          }
          if ("stack" in modifier) {
            modifier.stack(this[key], stack);
          }
        }
        return stack.join("\n");
      };
      Object.defineProperty(this, "stack", stackDescriptor);
    };
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util2.inherits(errorExError, Error);
    }
    return errorExError;
  };
  errorEx.append = function(str2, def) {
    return {
      message: function(v, message) {
        v = v || def;
        if (v) {
          message[0] += " " + str2.replace("%s", v.toString());
        }
        return message;
      }
    };
  };
  errorEx.line = function(str2, def) {
    return {
      line: function(v) {
        v = v || def;
        if (v) {
          return str2.replace("%s", v.toString());
        }
        return null;
      }
    };
  };
  module2.exports = errorEx;
});

// node_modules/json-parse-better-errors/index.js
var require_json_parse_better_errors = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = parseJson;
  function parseJson(txt, reviver, context) {
    context = context || 20;
    try {
      return JSON.parse(txt, reviver);
    } catch (e) {
      if (typeof txt !== "string") {
        const isEmptyArray = Array.isArray(txt) && txt.length === 0;
        const errorMessage = "Cannot parse " + (isEmptyArray ? "an empty array" : String(txt));
        throw new TypeError(errorMessage);
      }
      const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i);
      const errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      if (errIdx != null) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        e.message += ` while parsing near '${start === 0 ? "" : "..."}${txt.slice(start, end)}${end === txt.length ? "" : "..."}'`;
      } else {
        e.message += ` while parsing '${txt.slice(0, context * 2)}'`;
      }
      throw e;
    }
  }
});

// node_modules/parse-json/index.js
var require_parse_json = __commonJS((exports2, module2) => {
  "use strict";
  var errorEx = require_error_ex();
  var fallback = require_json_parse_better_errors();
  var JSONError = errorEx("JSONError", {
    fileName: errorEx.append("in %s")
  });
  module2.exports = (input, reviver, filename) => {
    if (typeof reviver === "string") {
      filename = reviver;
      reviver = null;
    }
    try {
      try {
        return JSON.parse(input, reviver);
      } catch (err) {
        fallback(input, reviver);
        throw err;
      }
    } catch (err) {
      err.message = err.message.replace(/\n/g, "");
      const jsonErr = new JSONError(err);
      if (filename) {
        jsonErr.fileName = filename;
      }
      throw jsonErr;
    }
  };
});

// node_modules/pify/index.js
var require_pify = __commonJS((exports2, module2) => {
  "use strict";
  var processFn = (fn, opts) => function() {
    const P = opts.promiseModule;
    const args = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    return new P((resolve, reject) => {
      if (opts.errorFirst) {
        args.push(function(err, result) {
          if (opts.multiArgs) {
            const results = new Array(arguments.length - 1);
            for (let i = 1; i < arguments.length; i++) {
              results[i - 1] = arguments[i];
            }
            if (err) {
              results.unshift(err);
              reject(results);
            } else {
              resolve(results);
            }
          } else if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      } else {
        args.push(function(result) {
          if (opts.multiArgs) {
            const results = new Array(arguments.length - 1);
            for (let i = 0; i < arguments.length; i++) {
              results[i] = arguments[i];
            }
            resolve(results);
          } else {
            resolve(result);
          }
        });
      }
      fn.apply(this, args);
    });
  };
  module2.exports = (obj, opts) => {
    opts = Object.assign({
      exclude: [/.+(Sync|Stream)$/],
      errorFirst: true,
      promiseModule: Promise
    }, opts);
    const filter = (key) => {
      const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
      return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    };
    let ret;
    if (typeof obj === "function") {
      ret = function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, opts).apply(this, arguments);
      };
    } else {
      ret = Object.create(Object.getPrototypeOf(obj));
    }
    for (const key in obj) {
      const x = obj[key];
      ret[key] = typeof x === "function" && filter(key) ? processFn(x, opts) : x;
    }
    return ret;
  };
});

// node_modules/load-json-file/index.js
var require_load_json_file = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var fs5 = require_graceful_fs();
  var stripBom = require_strip_bom();
  var parseJson = require_parse_json();
  var pify = require_pify();
  var parse = (data, fp) => parseJson(stripBom(data), path5.relative(".", fp));
  module2.exports = (fp) => pify(fs5.readFile)(fp, "utf8").then((data) => parse(data, fp));
  module2.exports.sync = (fp) => parse(fs5.readFileSync(fp, "utf8"), fp);
});

// node_modules/path-type/index.js
var require_path_type = __commonJS((exports2) => {
  "use strict";
  var fs5 = require("fs");
  var pify = require_pify();
  function type2(fn, fn2, fp) {
    if (typeof fp !== "string") {
      return Promise.reject(new TypeError(`Expected a string, got ${typeof fp}`));
    }
    return pify(fs5[fn])(fp).then((stats) => stats[fn2]()).catch((err) => {
      if (err.code === "ENOENT") {
        return false;
      }
      throw err;
    });
  }
  function typeSync(fn, fn2, fp) {
    if (typeof fp !== "string") {
      throw new TypeError(`Expected a string, got ${typeof fp}`);
    }
    try {
      return fs5[fn](fp)[fn2]();
    } catch (err) {
      if (err.code === "ENOENT") {
        return false;
      }
      throw err;
    }
  }
  exports2.file = type2.bind(null, "stat", "isFile");
  exports2.dir = type2.bind(null, "stat", "isDirectory");
  exports2.symlink = type2.bind(null, "lstat", "isSymbolicLink");
  exports2.fileSync = typeSync.bind(null, "statSync", "isFile");
  exports2.dirSync = typeSync.bind(null, "statSync", "isDirectory");
  exports2.symlinkSync = typeSync.bind(null, "lstatSync", "isSymbolicLink");
});

// node_modules/normalize-package-data/node_modules/semver/semver.js
var require_semver2 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range5(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range5(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range5;
  function Range5(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range5) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range5(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range5(range.value, options);
    }
    if (!(this instanceof Range5)) {
      return new Range5(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range5.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range5.prototype.toString = function() {
    return this.range;
  };
  Range5.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set2 = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set2 = set2.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set2 = set2.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set2;
  };
  Range5.prototype.intersects = function(range, options) {
    if (!(range instanceof Range5)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range5(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range5.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set2, version, options) {
    for (var i2 = 0; i2 < set2.length; i2++) {
      if (!set2[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set2.length; i2++) {
        debug(set2[i2].semver);
        if (set2[i2].semver === ANY) {
          continue;
        }
        if (set2[i2].semver.prerelease.length > 0) {
          var allowed = set2[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range5(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range5(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range5(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range5(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range5(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range5(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range5(r1, options);
    r2 = new Range5(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
});

// node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS((exports2, module2) => {
  module2.exports = [
    "0BSD",
    "AAL",
    "ADSL",
    "AFL-1.1",
    "AFL-1.2",
    "AFL-2.0",
    "AFL-2.1",
    "AFL-3.0",
    "AGPL-1.0-only",
    "AGPL-1.0-or-later",
    "AGPL-3.0-only",
    "AGPL-3.0-or-later",
    "AMDPLPA",
    "AML",
    "AMPAS",
    "ANTLR-PD",
    "ANTLR-PD-fallback",
    "APAFML",
    "APL-1.0",
    "APSL-1.0",
    "APSL-1.1",
    "APSL-1.2",
    "APSL-2.0",
    "Abstyles",
    "Adobe-2006",
    "Adobe-Glyph",
    "Afmparse",
    "Aladdin",
    "Apache-1.0",
    "Apache-1.1",
    "Apache-2.0",
    "Artistic-1.0",
    "Artistic-1.0-Perl",
    "Artistic-1.0-cl8",
    "Artistic-2.0",
    "BSD-1-Clause",
    "BSD-2-Clause",
    "BSD-2-Clause-Patent",
    "BSD-2-Clause-Views",
    "BSD-3-Clause",
    "BSD-3-Clause-Attribution",
    "BSD-3-Clause-Clear",
    "BSD-3-Clause-LBNL",
    "BSD-3-Clause-No-Nuclear-License",
    "BSD-3-Clause-No-Nuclear-License-2014",
    "BSD-3-Clause-No-Nuclear-Warranty",
    "BSD-3-Clause-Open-MPI",
    "BSD-4-Clause",
    "BSD-4-Clause-UC",
    "BSD-Protection",
    "BSD-Source-Code",
    "BSL-1.0",
    "BUSL-1.1",
    "Bahyph",
    "Barr",
    "Beerware",
    "BitTorrent-1.0",
    "BitTorrent-1.1",
    "BlueOak-1.0.0",
    "Borceux",
    "CAL-1.0",
    "CAL-1.0-Combined-Work-Exception",
    "CATOSL-1.1",
    "CC-BY-1.0",
    "CC-BY-2.0",
    "CC-BY-2.5",
    "CC-BY-3.0",
    "CC-BY-3.0-AT",
    "CC-BY-3.0-US",
    "CC-BY-4.0",
    "CC-BY-NC-1.0",
    "CC-BY-NC-2.0",
    "CC-BY-NC-2.5",
    "CC-BY-NC-3.0",
    "CC-BY-NC-4.0",
    "CC-BY-NC-ND-1.0",
    "CC-BY-NC-ND-2.0",
    "CC-BY-NC-ND-2.5",
    "CC-BY-NC-ND-3.0",
    "CC-BY-NC-ND-3.0-IGO",
    "CC-BY-NC-ND-4.0",
    "CC-BY-NC-SA-1.0",
    "CC-BY-NC-SA-2.0",
    "CC-BY-NC-SA-2.5",
    "CC-BY-NC-SA-3.0",
    "CC-BY-NC-SA-4.0",
    "CC-BY-ND-1.0",
    "CC-BY-ND-2.0",
    "CC-BY-ND-2.5",
    "CC-BY-ND-3.0",
    "CC-BY-ND-4.0",
    "CC-BY-SA-1.0",
    "CC-BY-SA-2.0",
    "CC-BY-SA-2.0-UK",
    "CC-BY-SA-2.5",
    "CC-BY-SA-3.0",
    "CC-BY-SA-3.0-AT",
    "CC-BY-SA-4.0",
    "CC-PDDC",
    "CC0-1.0",
    "CDDL-1.0",
    "CDDL-1.1",
    "CDLA-Permissive-1.0",
    "CDLA-Sharing-1.0",
    "CECILL-1.0",
    "CECILL-1.1",
    "CECILL-2.0",
    "CECILL-2.1",
    "CECILL-B",
    "CECILL-C",
    "CERN-OHL-1.1",
    "CERN-OHL-1.2",
    "CERN-OHL-P-2.0",
    "CERN-OHL-S-2.0",
    "CERN-OHL-W-2.0",
    "CNRI-Jython",
    "CNRI-Python",
    "CNRI-Python-GPL-Compatible",
    "CPAL-1.0",
    "CPL-1.0",
    "CPOL-1.02",
    "CUA-OPL-1.0",
    "Caldera",
    "ClArtistic",
    "Condor-1.1",
    "Crossword",
    "CrystalStacker",
    "Cube",
    "D-FSL-1.0",
    "DOC",
    "DSDP",
    "Dotseqn",
    "ECL-1.0",
    "ECL-2.0",
    "EFL-1.0",
    "EFL-2.0",
    "EPICS",
    "EPL-1.0",
    "EPL-2.0",
    "EUDatagrid",
    "EUPL-1.0",
    "EUPL-1.1",
    "EUPL-1.2",
    "Entessa",
    "ErlPL-1.1",
    "Eurosym",
    "FSFAP",
    "FSFUL",
    "FSFULLR",
    "FTL",
    "Fair",
    "Frameworx-1.0",
    "FreeImage",
    "GFDL-1.1-invariants-only",
    "GFDL-1.1-invariants-or-later",
    "GFDL-1.1-no-invariants-only",
    "GFDL-1.1-no-invariants-or-later",
    "GFDL-1.1-only",
    "GFDL-1.1-or-later",
    "GFDL-1.2-invariants-only",
    "GFDL-1.2-invariants-or-later",
    "GFDL-1.2-no-invariants-only",
    "GFDL-1.2-no-invariants-or-later",
    "GFDL-1.2-only",
    "GFDL-1.2-or-later",
    "GFDL-1.3-invariants-only",
    "GFDL-1.3-invariants-or-later",
    "GFDL-1.3-no-invariants-only",
    "GFDL-1.3-no-invariants-or-later",
    "GFDL-1.3-only",
    "GFDL-1.3-or-later",
    "GL2PS",
    "GLWTPL",
    "GPL-1.0-only",
    "GPL-1.0-or-later",
    "GPL-2.0-only",
    "GPL-2.0-or-later",
    "GPL-3.0-only",
    "GPL-3.0-or-later",
    "Giftware",
    "Glide",
    "Glulxe",
    "HPND",
    "HPND-sell-variant",
    "HTMLTIDY",
    "HaskellReport",
    "Hippocratic-2.1",
    "IBM-pibs",
    "ICU",
    "IJG",
    "IPA",
    "IPL-1.0",
    "ISC",
    "ImageMagick",
    "Imlib2",
    "Info-ZIP",
    "Intel",
    "Intel-ACPI",
    "Interbase-1.0",
    "JPNIC",
    "JSON",
    "JasPer-2.0",
    "LAL-1.2",
    "LAL-1.3",
    "LGPL-2.0-only",
    "LGPL-2.0-or-later",
    "LGPL-2.1-only",
    "LGPL-2.1-or-later",
    "LGPL-3.0-only",
    "LGPL-3.0-or-later",
    "LGPLLR",
    "LPL-1.0",
    "LPL-1.02",
    "LPPL-1.0",
    "LPPL-1.1",
    "LPPL-1.2",
    "LPPL-1.3a",
    "LPPL-1.3c",
    "Latex2e",
    "Leptonica",
    "LiLiQ-P-1.1",
    "LiLiQ-R-1.1",
    "LiLiQ-Rplus-1.1",
    "Libpng",
    "Linux-OpenIB",
    "MIT",
    "MIT-0",
    "MIT-CMU",
    "MIT-advertising",
    "MIT-enna",
    "MIT-feh",
    "MIT-open-group",
    "MITNFA",
    "MPL-1.0",
    "MPL-1.1",
    "MPL-2.0",
    "MPL-2.0-no-copyleft-exception",
    "MS-PL",
    "MS-RL",
    "MTLL",
    "MakeIndex",
    "MirOS",
    "Motosoto",
    "MulanPSL-1.0",
    "MulanPSL-2.0",
    "Multics",
    "Mup",
    "NASA-1.3",
    "NBPL-1.0",
    "NCGL-UK-2.0",
    "NCSA",
    "NGPL",
    "NIST-PD",
    "NIST-PD-fallback",
    "NLOD-1.0",
    "NLPL",
    "NOSL",
    "NPL-1.0",
    "NPL-1.1",
    "NPOSL-3.0",
    "NRL",
    "NTP",
    "NTP-0",
    "Naumen",
    "Net-SNMP",
    "NetCDF",
    "Newsletr",
    "Nokia",
    "Noweb",
    "O-UDA-1.0",
    "OCCT-PL",
    "OCLC-2.0",
    "ODC-By-1.0",
    "ODbL-1.0",
    "OFL-1.0",
    "OFL-1.0-RFN",
    "OFL-1.0-no-RFN",
    "OFL-1.1",
    "OFL-1.1-RFN",
    "OFL-1.1-no-RFN",
    "OGC-1.0",
    "OGL-Canada-2.0",
    "OGL-UK-1.0",
    "OGL-UK-2.0",
    "OGL-UK-3.0",
    "OGTSL",
    "OLDAP-1.1",
    "OLDAP-1.2",
    "OLDAP-1.3",
    "OLDAP-1.4",
    "OLDAP-2.0",
    "OLDAP-2.0.1",
    "OLDAP-2.1",
    "OLDAP-2.2",
    "OLDAP-2.2.1",
    "OLDAP-2.2.2",
    "OLDAP-2.3",
    "OLDAP-2.4",
    "OLDAP-2.5",
    "OLDAP-2.6",
    "OLDAP-2.7",
    "OLDAP-2.8",
    "OML",
    "OPL-1.0",
    "OSET-PL-2.1",
    "OSL-1.0",
    "OSL-1.1",
    "OSL-2.0",
    "OSL-2.1",
    "OSL-3.0",
    "OpenSSL",
    "PDDL-1.0",
    "PHP-3.0",
    "PHP-3.01",
    "PSF-2.0",
    "Parity-6.0.0",
    "Parity-7.0.0",
    "Plexus",
    "PolyForm-Noncommercial-1.0.0",
    "PolyForm-Small-Business-1.0.0",
    "PostgreSQL",
    "Python-2.0",
    "QPL-1.0",
    "Qhull",
    "RHeCos-1.1",
    "RPL-1.1",
    "RPL-1.5",
    "RPSL-1.0",
    "RSA-MD",
    "RSCPL",
    "Rdisc",
    "Ruby",
    "SAX-PD",
    "SCEA",
    "SGI-B-1.0",
    "SGI-B-1.1",
    "SGI-B-2.0",
    "SHL-0.5",
    "SHL-0.51",
    "SISSL",
    "SISSL-1.2",
    "SMLNJ",
    "SMPPL",
    "SNIA",
    "SPL-1.0",
    "SSH-OpenSSH",
    "SSH-short",
    "SSPL-1.0",
    "SWL",
    "Saxpath",
    "Sendmail",
    "Sendmail-8.23",
    "SimPL-2.0",
    "Sleepycat",
    "Spencer-86",
    "Spencer-94",
    "Spencer-99",
    "SugarCRM-1.1.3",
    "TAPR-OHL-1.0",
    "TCL",
    "TCP-wrappers",
    "TMate",
    "TORQUE-1.1",
    "TOSL",
    "TU-Berlin-1.0",
    "TU-Berlin-2.0",
    "UCL-1.0",
    "UPL-1.0",
    "Unicode-DFS-2015",
    "Unicode-DFS-2016",
    "Unicode-TOU",
    "Unlicense",
    "VOSTROM",
    "VSL-1.0",
    "Vim",
    "W3C",
    "W3C-19980720",
    "W3C-20150513",
    "WTFPL",
    "Watcom-1.0",
    "Wsuipa",
    "X11",
    "XFree86-1.1",
    "XSkat",
    "Xerox",
    "Xnet",
    "YPL-1.0",
    "YPL-1.1",
    "ZPL-1.1",
    "ZPL-2.0",
    "ZPL-2.1",
    "Zed",
    "Zend-2.0",
    "Zimbra-1.3",
    "Zimbra-1.4",
    "Zlib",
    "blessing",
    "bzip2-1.0.5",
    "bzip2-1.0.6",
    "copyleft-next-0.3.0",
    "copyleft-next-0.3.1",
    "curl",
    "diffmark",
    "dvipdfm",
    "eGenix",
    "etalab-2.0",
    "gSOAP-1.3b",
    "gnuplot",
    "iMatix",
    "libpng-2.0",
    "libselinux-1.0",
    "libtiff",
    "mpich2",
    "psfrag",
    "psutils",
    "xinetd",
    "xpp",
    "zlib-acknowledgement"
  ];
});

// node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS((exports2, module2) => {
  module2.exports = [
    "AGPL-1.0",
    "AGPL-3.0",
    "BSD-2-Clause-FreeBSD",
    "BSD-2-Clause-NetBSD",
    "GFDL-1.1",
    "GFDL-1.2",
    "GFDL-1.3",
    "GPL-1.0",
    "GPL-2.0",
    "GPL-2.0-with-GCC-exception",
    "GPL-2.0-with-autoconf-exception",
    "GPL-2.0-with-bison-exception",
    "GPL-2.0-with-classpath-exception",
    "GPL-2.0-with-font-exception",
    "GPL-3.0",
    "GPL-3.0-with-GCC-exception",
    "GPL-3.0-with-autoconf-exception",
    "LGPL-2.0",
    "LGPL-2.1",
    "LGPL-3.0",
    "Nunit",
    "StandardML-NJ",
    "eCos-2.0",
    "wxWindows"
  ];
});

// node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS((exports2, module2) => {
  module2.exports = [
    "389-exception",
    "Autoconf-exception-2.0",
    "Autoconf-exception-3.0",
    "Bison-exception-2.2",
    "Bootloader-exception",
    "Classpath-exception-2.0",
    "CLISP-exception-2.0",
    "DigiRule-FOSS-exception",
    "eCos-exception-2.0",
    "Fawkes-Runtime-exception",
    "FLTK-exception",
    "Font-exception-2.0",
    "freertos-exception-2.0",
    "GCC-exception-2.0",
    "GCC-exception-3.1",
    "gnu-javamail-exception",
    "GPL-3.0-linking-exception",
    "GPL-3.0-linking-source-exception",
    "GPL-CC-1.0",
    "i2p-gpl-java-exception",
    "Libtool-exception",
    "Linux-syscall-note",
    "LLVM-exception",
    "LZMA-exception",
    "mif-exception",
    "Nokia-Qt-exception-1.1",
    "OCaml-LGPL-linking-exception",
    "OCCT-exception-1.0",
    "OpenJDK-assembly-exception-1.0",
    "openvpn-openssl-exception",
    "PS-or-PDF-font-exception-20170817",
    "Qt-GPL-exception-1.0",
    "Qt-LGPL-exception-1.1",
    "Qwt-exception-1.0",
    "Swift-exception",
    "u-boot-exception-2.0",
    "Universal-FOSS-exception-1.0",
    "WxWindows-exception-3.1"
  ];
});

// node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS((exports2, module2) => {
  "use strict";
  var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
  var exceptions = require_spdx_exceptions();
  module2.exports = function(source) {
    var index = 0;
    function hasMore() {
      return index < source.length;
    }
    function read(value) {
      if (value instanceof RegExp) {
        var chars = source.slice(index);
        var match = chars.match(value);
        if (match) {
          index += match[0].length;
          return match[0];
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length;
          return value;
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/);
    }
    function operator() {
      var string;
      var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
      for (var i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i]);
        if (string) {
          break;
        }
      }
      if (string === "+" && index > 1 && source[index - 2] === " ") {
        throw new Error("Space before `+`");
      }
      return string && {
        type: "OPERATOR",
        string
      };
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/);
    }
    function expectIdstring() {
      var string = idstring();
      if (!string) {
        throw new Error("Expected idstring at offset " + index);
      }
      return string;
    }
    function documentRef() {
      if (read("DocumentRef-")) {
        var string = expectIdstring();
        return {type: "DOCUMENTREF", string};
      }
    }
    function licenseRef() {
      if (read("LicenseRef-")) {
        var string = expectIdstring();
        return {type: "LICENSEREF", string};
      }
    }
    function identifier() {
      var begin = index;
      var string = idstring();
      if (licenses.indexOf(string) !== -1) {
        return {
          type: "LICENSE",
          string
        };
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: "EXCEPTION",
          string
        };
      }
      index = begin;
    }
    function parseToken() {
      return operator() || documentRef() || licenseRef() || identifier();
    }
    var tokens = [];
    while (hasMore()) {
      skipWhitespace();
      if (!hasMore()) {
        break;
      }
      var token = parseToken();
      if (!token) {
        throw new Error("Unexpected `" + source[index] + "` at offset " + index);
      }
      tokens.push(token);
    }
    return tokens;
  };
});

// node_modules/spdx-expression-parse/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(tokens) {
    var index = 0;
    function hasMore() {
      return index < tokens.length;
    }
    function token() {
      return hasMore() ? tokens[index] : null;
    }
    function next() {
      if (!hasMore()) {
        throw new Error();
      }
      index++;
    }
    function parseOperator(operator) {
      var t = token();
      if (t && t.type === "OPERATOR" && operator === t.string) {
        next();
        return t.string;
      }
    }
    function parseWith() {
      if (parseOperator("WITH")) {
        var t = token();
        if (t && t.type === "EXCEPTION") {
          next();
          return t.string;
        }
        throw new Error("Expected exception after `WITH`");
      }
    }
    function parseLicenseRef() {
      var begin = index;
      var string = "";
      var t = token();
      if (t.type === "DOCUMENTREF") {
        next();
        string += "DocumentRef-" + t.string + ":";
        if (!parseOperator(":")) {
          throw new Error("Expected `:` after `DocumentRef-...`");
        }
      }
      t = token();
      if (t.type === "LICENSEREF") {
        next();
        string += "LicenseRef-" + t.string;
        return {license: string};
      }
      index = begin;
    }
    function parseLicense() {
      var t = token();
      if (t && t.type === "LICENSE") {
        next();
        var node2 = {license: t.string};
        if (parseOperator("+")) {
          node2.plus = true;
        }
        var exception2 = parseWith();
        if (exception2) {
          node2.exception = exception2;
        }
        return node2;
      }
    }
    function parseParenthesizedExpression() {
      var left = parseOperator("(");
      if (!left) {
        return;
      }
      var expr = parseExpression();
      if (!parseOperator(")")) {
        throw new Error("Expected `)`");
      }
      return expr;
    }
    function parseAtom() {
      return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        var left = nextParser();
        if (!left) {
          return;
        }
        if (!parseOperator(operator)) {
          return left;
        }
        var right = parseBinaryOp();
        if (!right) {
          throw new Error("Expected expression");
        }
        return {
          left,
          conjunction: operator.toLowerCase(),
          right
        };
      };
    }
    var parseAnd = makeBinaryOpParser("AND", parseAtom);
    var parseExpression = makeBinaryOpParser("OR", parseAnd);
    var node = parseExpression();
    if (!node || hasMore()) {
      throw new Error("Syntax error");
    }
    return node;
  };
});

// node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS((exports2, module2) => {
  "use strict";
  var scan = require_scan();
  var parse = require_parse();
  module2.exports = function(source) {
    return parse(scan(source));
  };
});

// node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS((exports2, module2) => {
  var parse = require_spdx_expression_parse();
  var spdxLicenseIds = require_spdx_license_ids();
  function valid(string) {
    try {
      parse(string);
      return true;
    } catch (error) {
      return false;
    }
  }
  var transpositions = [
    ["APGL", "AGPL"],
    ["Gpl", "GPL"],
    ["GLP", "GPL"],
    ["APL", "Apache"],
    ["ISD", "ISC"],
    ["GLP", "GPL"],
    ["IST", "ISC"],
    ["Claude", "Clause"],
    [" or later", "+"],
    [" International", ""],
    ["GNU", "GPL"],
    ["GUN", "GPL"],
    ["+", ""],
    ["GNU GPL", "GPL"],
    ["GNU/GPL", "GPL"],
    ["GNU GLP", "GPL"],
    ["GNU General Public License", "GPL"],
    ["Gnu public license", "GPL"],
    ["GNU Public License", "GPL"],
    ["GNU GENERAL PUBLIC LICENSE", "GPL"],
    ["MTI", "MIT"],
    ["Mozilla Public License", "MPL"],
    ["Universal Permissive License", "UPL"],
    ["WTH", "WTF"],
    ["-License", ""]
  ];
  var TRANSPOSED = 0;
  var CORRECT = 1;
  var transforms = [
    function(argument) {
      return argument.toUpperCase();
    },
    function(argument) {
      return argument.trim();
    },
    function(argument) {
      return argument.replace(/\./g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "");
    },
    function(argument) {
      return argument.replace(/\s+/g, "-");
    },
    function(argument) {
      return argument.replace("v", "-");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1");
    },
    function(argument) {
      return argument.replace(/,?\s*(\d)/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
    },
    function(argument) {
      return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
    },
    function(argument) {
      return argument[0].toUpperCase() + argument.slice(1);
    },
    function(argument) {
      return argument.replace("/", "-");
    },
    function(argument) {
      return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
    },
    function(argument) {
      if (argument.indexOf("3.0") !== -1) {
        return argument + "-or-later";
      } else {
        return argument + "-only";
      }
    },
    function(argument) {
      return argument + "only";
    },
    function(argument) {
      return argument.replace(/(\d)$/, "-$1.0");
    },
    function(argument) {
      return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
    },
    function(argument) {
      return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
    },
    function(argument) {
      return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
    },
    function(argument) {
      return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
    },
    function(argument) {
      return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
    },
    function(argument) {
      return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
    },
    function(argument) {
      return "CC-" + argument;
    },
    function(argument) {
      return "CC-" + argument + "-4.0";
    },
    function(argument) {
      return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
    },
    function(argument) {
      return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
    }
  ];
  var licensesWithVersions = spdxLicenseIds.map(function(id) {
    var match = /^(.*)-\d+\.\d+$/.exec(id);
    return match ? [match[0], match[1]] : [id, null];
  }).reduce(function(objectMap, item) {
    var key = item[1];
    objectMap[key] = objectMap[key] || [];
    objectMap[key].push(item[0]);
    return objectMap;
  }, {});
  var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
    return [key, licensesWithVersions[key]];
  }).filter(function identifySoleVersions(item) {
    return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
  }).map(function createLastResorts(item) {
    return [item[0], item[1][0]];
  });
  licensesWithVersions = void 0;
  var lastResorts = [
    ["UNLI", "Unlicense"],
    ["WTF", "WTFPL"],
    ["2 CLAUSE", "BSD-2-Clause"],
    ["2-CLAUSE", "BSD-2-Clause"],
    ["3 CLAUSE", "BSD-3-Clause"],
    ["3-CLAUSE", "BSD-3-Clause"],
    ["AFFERO", "AGPL-3.0-or-later"],
    ["AGPL", "AGPL-3.0-or-later"],
    ["APACHE", "Apache-2.0"],
    ["ARTISTIC", "Artistic-2.0"],
    ["Affero", "AGPL-3.0-or-later"],
    ["BEER", "Beerware"],
    ["BOOST", "BSL-1.0"],
    ["BSD", "BSD-2-Clause"],
    ["CDDL", "CDDL-1.1"],
    ["ECLIPSE", "EPL-1.0"],
    ["FUCK", "WTFPL"],
    ["GNU", "GPL-3.0-or-later"],
    ["LGPL", "LGPL-3.0-or-later"],
    ["GPLV1", "GPL-1.0-only"],
    ["GPL-1", "GPL-1.0-only"],
    ["GPLV2", "GPL-2.0-only"],
    ["GPL-2", "GPL-2.0-only"],
    ["GPL", "GPL-3.0-or-later"],
    ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
    ["MIT", "MIT"],
    ["MPL", "MPL-2.0"],
    ["X11", "X11"],
    ["ZLIB", "Zlib"]
  ].concat(licensesWithOneVersion);
  var SUBSTRING = 0;
  var IDENTIFIER = 1;
  var validTransformation = function(identifier) {
    for (var i = 0; i < transforms.length; i++) {
      var transformed = transforms[i](identifier).trim();
      if (transformed !== identifier && valid(transformed)) {
        return transformed;
      }
    }
    return null;
  };
  var validLastResort = function(identifier) {
    var upperCased = identifier.toUpperCase();
    for (var i = 0; i < lastResorts.length; i++) {
      var lastResort = lastResorts[i];
      if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
        return lastResort[IDENTIFIER];
      }
    }
    return null;
  };
  var anyCorrection = function(identifier, check) {
    for (var i = 0; i < transpositions.length; i++) {
      var transposition = transpositions[i];
      var transposed = transposition[TRANSPOSED];
      if (identifier.indexOf(transposed) > -1) {
        var corrected = identifier.replace(transposed, transposition[CORRECT]);
        var checked = check(corrected);
        if (checked !== null) {
          return checked;
        }
      }
    }
    return null;
  };
  module2.exports = function(identifier, options) {
    options = options || {};
    var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
    function postprocess(value) {
      return upgrade ? upgradeGPLs(value) : value;
    }
    var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
    if (!validArugment) {
      throw Error("Invalid argument. Expected non-empty string.");
    }
    identifier = identifier.trim();
    if (valid(identifier)) {
      return postprocess(identifier);
    }
    var noPlus = identifier.replace(/\+$/, "").trim();
    if (valid(noPlus)) {
      return postprocess(noPlus);
    }
    var transformed = validTransformation(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, function(argument) {
      if (valid(argument)) {
        return argument;
      }
      return validTransformation(argument);
    });
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = validLastResort(identifier);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    transformed = anyCorrection(identifier, validLastResort);
    if (transformed !== null) {
      return postprocess(transformed);
    }
    return null;
  };
  function upgradeGPLs(value) {
    if ([
      "GPL-1.0",
      "LGPL-1.0",
      "AGPL-1.0",
      "GPL-2.0",
      "LGPL-2.0",
      "AGPL-2.0",
      "LGPL-2.1"
    ].indexOf(value) !== -1) {
      return value + "-only";
    } else if ([
      "GPL-1.0+",
      "GPL-2.0+",
      "GPL-3.0+",
      "LGPL-2.0+",
      "LGPL-2.1+",
      "LGPL-3.0+",
      "AGPL-1.0+",
      "AGPL-3.0+"
    ].indexOf(value) !== -1) {
      return value.replace(/\+$/, "-or-later");
    } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
      return value + "-or-later";
    } else {
      return value;
    }
  }
});

// node_modules/validate-npm-package-license/index.js
var require_validate_npm_package_license = __commonJS((exports2, module2) => {
  var parse = require_spdx_expression_parse();
  var correct = require_spdx_correct();
  var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
  var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
  function startsWith(prefix, string) {
    return string.slice(0, prefix.length) === prefix;
  }
  function usesLicenseRef(ast) {
    if (ast.hasOwnProperty("license")) {
      var license = ast.license;
      return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
    } else {
      return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
    }
  }
  module2.exports = function(argument) {
    var ast;
    try {
      ast = parse(argument);
    } catch (e) {
      var match;
      if (argument === "UNLICENSED" || argument === "UNLICENCED") {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          unlicensed: true
        };
      } else if (match = fileReferenceRE.exec(argument)) {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          inFile: match[1]
        };
      } else {
        var result = {
          validForOldPackages: false,
          validForNewPackages: false,
          warnings: [genericWarning]
        };
        if (argument.trim().length !== 0) {
          var corrected = correct(argument);
          if (corrected) {
            result.warnings.push('license is similar to the valid expression "' + corrected + '"');
          }
        }
        return result;
      }
    }
    if (usesLicenseRef(ast)) {
      return {
        validForNewPackages: false,
        validForOldPackages: false,
        spdx: true,
        warnings: [genericWarning]
      };
    } else {
      return {
        validForNewPackages: true,
        validForOldPackages: true,
        spdx: true
      };
    }
  };
});

// node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = module2.exports = {
    github: {
      protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
      domain: "github.com",
      treepath: "tree",
      filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
      tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
    },
    bitbucket: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "bitbucket.org",
      treepath: "src",
      tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
    },
    gitlab: {
      protocols: ["git+ssh", "git+https", "ssh", "https"],
      domain: "gitlab.com",
      treepath: "tree",
      bugstemplate: "https://{domain}/{user}/{project}/issues",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
      tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
      pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
    },
    gist: {
      protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
      domain: "gist.github.com",
      pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
      filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
      bugstemplate: "https://{domain}/{project}",
      gittemplate: "git://{domain}/{project}.git{#committish}",
      sshtemplate: "git@{domain}:/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{project}{/committish}",
      browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
      docstemplate: "https://{domain}/{project}{/committish}",
      httpstemplate: "git+https://{domain}/{project}.git{#committish}",
      shortcuttemplate: "{type}:{project}{#committish}",
      pathtemplate: "{project}{#committish}",
      tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
      hashformat: function(fragment) {
        return "file-" + formatHashFragment(fragment);
      }
    }
  };
  var gitHostDefaults = {
    sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
    sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
    browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
    browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
    docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
    httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
    filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
    shortcuttemplate: "{type}:{user}/{project}{#committish}",
    pathtemplate: "{user}/{project}{#committish}",
    pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
    hashformat: formatHashFragment
  };
  Object.keys(gitHosts).forEach(function(name) {
    Object.keys(gitHostDefaults).forEach(function(key) {
      if (gitHosts[name][key])
        return;
      gitHosts[name][key] = gitHostDefaults[key];
    });
    gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
      return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
    }).join("|") + "):$");
  });
  function formatHashFragment(fragment) {
    return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
  }
});

// node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS((exports2, module2) => {
  "use strict";
  var gitHosts = require_git_host_info();
  var extend3 = Object.assign || function _extend(target, source) {
    if (source === null || typeof source !== "object")
      return target;
    var keys = Object.keys(source);
    var i = keys.length;
    while (i--) {
      target[keys[i]] = source[keys[i]];
    }
    return target;
  };
  module2.exports = GitHost;
  function GitHost(type2, user, auth, project, committish, defaultRepresentation, opts) {
    var gitHostInfo = this;
    gitHostInfo.type = type2;
    Object.keys(gitHosts[type2]).forEach(function(key) {
      gitHostInfo[key] = gitHosts[type2][key];
    });
    gitHostInfo.user = user;
    gitHostInfo.auth = auth;
    gitHostInfo.project = project;
    gitHostInfo.committish = committish;
    gitHostInfo.default = defaultRepresentation;
    gitHostInfo.opts = opts || {};
  }
  GitHost.prototype.hash = function() {
    return this.committish ? "#" + this.committish : "";
  };
  GitHost.prototype._fill = function(template, opts) {
    if (!template)
      return;
    var vars = extend3({}, opts);
    vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "";
    opts = extend3(extend3({}, this.opts), opts);
    var self2 = this;
    Object.keys(this).forEach(function(key) {
      if (self2[key] != null && vars[key] == null)
        vars[key] = self2[key];
    });
    var rawAuth = vars.auth;
    var rawcommittish = vars.committish;
    var rawFragment = vars.fragment;
    var rawPath = vars.path;
    var rawProject = vars.project;
    Object.keys(vars).forEach(function(key) {
      var value = vars[key];
      if ((key === "path" || key === "project") && typeof value === "string") {
        vars[key] = value.split("/").map(function(pathComponent) {
          return encodeURIComponent(pathComponent);
        }).join("/");
      } else {
        vars[key] = encodeURIComponent(value);
      }
    });
    vars["auth@"] = rawAuth ? rawAuth + "@" : "";
    vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "";
    vars.fragment = vars.fragment ? vars.fragment : "";
    vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "";
    vars["/path"] = vars.path ? "/" + vars.path : "";
    vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/");
    if (opts.noCommittish) {
      vars["#committish"] = "";
      vars["/tree/committish"] = "";
      vars["/committish"] = "";
      vars.committish = "";
    } else {
      vars["#committish"] = rawcommittish ? "#" + rawcommittish : "";
      vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "";
      vars["/committish"] = vars.committish ? "/" + vars.committish : "";
      vars.committish = vars.committish || "master";
    }
    var res = template;
    Object.keys(vars).forEach(function(key) {
      res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
    });
    if (opts.noGitPlus) {
      return res.replace(/^git[+]/, "");
    } else {
      return res;
    }
  };
  GitHost.prototype.ssh = function(opts) {
    return this._fill(this.sshtemplate, opts);
  };
  GitHost.prototype.sshurl = function(opts) {
    return this._fill(this.sshurltemplate, opts);
  };
  GitHost.prototype.browse = function(P, F, opts) {
    if (typeof P === "string") {
      if (typeof F !== "string") {
        opts = F;
        F = null;
      }
      return this._fill(this.browsefiletemplate, extend3({
        fragment: F,
        path: P
      }, opts));
    } else {
      return this._fill(this.browsetemplate, P);
    }
  };
  GitHost.prototype.docs = function(opts) {
    return this._fill(this.docstemplate, opts);
  };
  GitHost.prototype.bugs = function(opts) {
    return this._fill(this.bugstemplate, opts);
  };
  GitHost.prototype.https = function(opts) {
    return this._fill(this.httpstemplate, opts);
  };
  GitHost.prototype.git = function(opts) {
    return this._fill(this.gittemplate, opts);
  };
  GitHost.prototype.shortcut = function(opts) {
    return this._fill(this.shortcuttemplate, opts);
  };
  GitHost.prototype.path = function(opts) {
    return this._fill(this.pathtemplate, opts);
  };
  GitHost.prototype.tarball = function(opts_) {
    var opts = extend3({}, opts_, {noCommittish: false});
    return this._fill(this.tarballtemplate, opts);
  };
  GitHost.prototype.file = function(P, opts) {
    return this._fill(this.filetemplate, extend3({path: P}, opts));
  };
  GitHost.prototype.getDefaultRepresentation = function() {
    return this.default;
  };
  GitHost.prototype.toString = function(opts) {
    if (this.default && typeof this[this.default] === "function")
      return this[this.default](opts);
    return this.sshurl(opts);
  };
});

// node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS((exports2, module2) => {
  "use strict";
  var url = require("url");
  var gitHosts = require_git_host_info();
  var GitHost = module2.exports = require_git_host();
  var protocolToRepresentationMap = {
    "git+ssh:": "sshurl",
    "git+https:": "https",
    "ssh:": "sshurl",
    "git:": "git"
  };
  function protocolToRepresentation(protocol) {
    return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
  }
  var authProtocols = {
    "git:": true,
    "https:": true,
    "git+https:": true,
    "http:": true,
    "git+http:": true
  };
  var cache = {};
  module2.exports.fromUrl = function(giturl, opts) {
    if (typeof giturl !== "string")
      return;
    var key = giturl + JSON.stringify(opts || {});
    if (!(key in cache)) {
      cache[key] = fromUrl(giturl, opts);
    }
    return cache[key];
  };
  function fromUrl(giturl, opts) {
    if (giturl == null || giturl === "")
      return;
    var url2 = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? "github:" + giturl : giturl);
    var parsed = parseGitUrl(url2);
    var shortcutMatch = url2.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/);
    var matches = Object.keys(gitHosts).map(function(gitHostName) {
      try {
        var gitHostInfo = gitHosts[gitHostName];
        var auth = null;
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = parsed.auth;
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
        var user = null;
        var project = null;
        var defaultRepresentation = null;
        if (shortcutMatch && shortcutMatch[1] === gitHostName) {
          user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);
          project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, ""));
          defaultRepresentation = "shortcut";
        } else {
          if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain)
            return;
          if (!gitHostInfo.protocols_re.test(parsed.protocol))
            return;
          if (!parsed.path)
            return;
          var pathmatch = gitHostInfo.pathmatch;
          var matched = parsed.path.match(pathmatch);
          if (!matched)
            return;
          if (matched[1] !== null && matched[1] !== void 0) {
            user = decodeURIComponent(matched[1].replace(/^:/, ""));
          }
          project = decodeURIComponent(matched[2]);
          defaultRepresentation = protocolToRepresentation(parsed.protocol);
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
      } catch (ex) {
        if (ex instanceof URIError) {
        } else
          throw ex;
      }
    }).filter(function(gitHostInfo) {
      return gitHostInfo;
    });
    if (matches.length !== 1)
      return;
    return matches[0];
  }
  function isGitHubShorthand(arg) {
    return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
  }
  function fixupUnqualifiedGist(giturl) {
    var parsed = url.parse(giturl);
    if (parsed.protocol === "gist:" && parsed.host && !parsed.path) {
      return parsed.protocol + "/" + parsed.host;
    } else {
      return giturl;
    }
  }
  function parseGitUrl(giturl) {
    var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
    if (!matched) {
      var legacy = url.parse(giturl);
      if (legacy.auth && typeof url.URL === "function") {
        var authmatch = giturl.match(/[^@]+@[^:/]+/);
        if (authmatch) {
          var whatwg = new url.URL(authmatch[0]);
          legacy.auth = whatwg.username || "";
          if (whatwg.password)
            legacy.auth += ":" + whatwg.password;
        }
      }
      return legacy;
    }
    return {
      protocol: "git+ssh:",
      slashes: true,
      auth: matched[1],
      host: matched[2],
      port: null,
      hostname: matched[2],
      hash: matched[4],
      search: null,
      query: null,
      pathname: "/" + matched[3],
      path: "/" + matched[3],
      href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
    };
  }
});

// node_modules/normalize-package-data/node_modules/resolve/lib/caller.js
var require_caller2 = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths2 = __commonJS((exports2, module2) => {
  var path5 = require("path");
  var parse = path5.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path5.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module2.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports2, module2) => {
  module2.exports = function(x, opts) {
    return opts || {};
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// node_modules/has/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// node_modules/is-core-module/core.json
var require_core3 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    "path/posix": ">= 15.3",
    "path/win32": ">= 15.3",
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "util/types": ">= 15.3",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports2, module2) => {
  "use strict";
  var has = require_src2();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core3();
  module2.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/async.js
var require_async2 = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var path5 = require("path");
  var caller = require_caller2();
  var nodeModulesPaths = require_node_modules_paths2();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = fs5.realpath && typeof fs5.realpath.native === "function" ? fs5.realpath.native : fs5.realpath;
  var defaultIsFile = function isFile(file, cb) {
    fs5.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs5.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path5.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs5.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path5.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = path5.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path5.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load2(exts, x2, loadAsFilePackage);
      function load2(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path5.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path5.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load2([""].concat(extensions.slice()), path5.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load2(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path5.dirname(dir), cb2);
        var pkgfile = path5.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path5.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path5.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path5.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path5.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path5.join(x2, "index"), pkg2, cb2);
                var dir = path5.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path5.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path5.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      isDirectory(path5.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/core.json
var require_core4 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "assert/strict": ">= 15",
    async_hooks: ">= 8",
    buffer_ieee754: "< 0.9.7",
    buffer: true,
    child_process: true,
    cluster: true,
    console: true,
    constants: true,
    crypto: true,
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    diagnostics_channel: ">= 15.1",
    dns: true,
    "dns/promises": ">= 15",
    domain: ">= 0.7.12",
    events: true,
    freelist: "< 6",
    fs: true,
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    _http_agent: ">= 0.11.1",
    _http_client: ">= 0.11.1",
    _http_common: ">= 0.11.1",
    _http_incoming: ">= 0.11.1",
    _http_outgoing: ">= 0.11.1",
    _http_server: ">= 0.11.1",
    http: true,
    http2: ">= 8.8",
    https: true,
    inspector: ">= 8.0.0",
    _linklist: "< 8",
    module: true,
    net: true,
    "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    os: true,
    path: true,
    "path/posix": ">= 15.3",
    "path/win32": ">= 15.3",
    perf_hooks: ">= 8.5",
    process: ">= 1",
    punycode: true,
    querystring: true,
    readline: true,
    repl: true,
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    _stream_transform: ">= 0.9.4",
    _stream_wrap: ">= 1.4.1",
    _stream_passthrough: ">= 0.9.4",
    _stream_readable: ">= 0.9.4",
    _stream_writable: ">= 0.9.4",
    stream: true,
    "stream/promises": ">= 15",
    string_decoder: true,
    sys: [">= 0.6 && < 0.7", ">= 0.8"],
    timers: true,
    "timers/promises": ">= 15",
    _tls_common: ">= 0.11.13",
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    tls: true,
    trace_events: ">= 10",
    tty: true,
    url: true,
    util: true,
    "util/types": ">= 15.3",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
    v8: ">= 1",
    vm: true,
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    zlib: true
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/core.js
var require_core5 = __commonJS((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(current[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      } else {
        return false;
      }
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core4();
  var core2 = {};
  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core2[mod] = versionIncluded(data[mod]);
    }
  }
  module2.exports = core2;
});

// node_modules/normalize-package-data/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports2, module2) => {
  var isCoreModule = require_is_core_module();
  module2.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// node_modules/normalize-package-data/node_modules/resolve/lib/sync.js
var require_sync2 = __commonJS((exports2, module2) => {
  var isCore = require_is_core_module();
  var fs5 = require("fs");
  var path5 = require("path");
  var caller = require_caller2();
  var nodeModulesPaths = require_node_modules_paths2();
  var normalizeOptions = require_normalize_options();
  var realpathFS = fs5.realpathSync && typeof fs5.realpathSync.native === "function" ? fs5.realpathSync.native : fs5.realpathSync;
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs5.statSync(file);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isFile() || stat.isFIFO();
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs5.statSync(dir);
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path5.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs5.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path5.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || [];
    var absoluteStart = maybeRealpathSync(realpathSync, path5.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path5.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path5.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path5.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path5.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path5.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path5.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return {pkg, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path5.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path5.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path5.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path5.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path5.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// node_modules/normalize-package-data/node_modules/resolve/index.js
var require_resolve2 = __commonJS((exports2, module2) => {
  var async = require_async2();
  async.core = require_core5();
  async.isCore = require_is_core();
  async.sync = require_sync2();
  module2.exports = async;
});

// node_modules/normalize-package-data/lib/extract_description.js
var require_extract_description = __commonJS((exports2, module2) => {
  module2.exports = extractDescription;
  function extractDescription(d) {
    if (!d)
      return;
    if (d === "ERROR: No README data found!")
      return;
    d = d.trim().split("\n");
    for (var s = 0; d[s] && d[s].trim().match(/^(#|$)/); s++)
      ;
    var l = d.length;
    for (var e = s + 1; e < l && d[e].trim(); e++)
      ;
    return d.slice(s, e).join(" ").trim();
  }
});

// node_modules/normalize-package-data/lib/typos.json
var require_typos = __commonJS((exports2, module2) => {
  module2.exports = {
    topLevel: {
      dependancies: "dependencies",
      dependecies: "dependencies",
      depdenencies: "dependencies",
      devEependencies: "devDependencies",
      depends: "dependencies",
      "dev-dependencies": "devDependencies",
      devDependences: "devDependencies",
      devDepenencies: "devDependencies",
      devdependencies: "devDependencies",
      repostitory: "repository",
      repo: "repository",
      prefereGlobal: "preferGlobal",
      hompage: "homepage",
      hampage: "homepage",
      autohr: "author",
      autor: "author",
      contributers: "contributors",
      publicationConfig: "publishConfig",
      script: "scripts"
    },
    bugs: {web: "url", name: "url"},
    script: {server: "start", tests: "test"}
  };
});

// node_modules/normalize-package-data/lib/fixer.js
var require_fixer = __commonJS((exports2, module2) => {
  var semver = require_semver2();
  var validateLicense = require_validate_npm_package_license();
  var hostedGitInfo = require_hosted_git_info();
  var isBuiltinModule = require_resolve2().isCore;
  var depTypes = ["dependencies", "devDependencies", "optionalDependencies"];
  var extractDescription = require_extract_description();
  var url = require("url");
  var typos = require_typos();
  var fixer = module2.exports = {
    warn: function() {
    },
    fixRepositoryField: function(data) {
      if (data.repositories) {
        this.warn("repositories");
        data.repository = data.repositories[0];
      }
      if (!data.repository)
        return this.warn("missingRepository");
      if (typeof data.repository === "string") {
        data.repository = {
          type: "git",
          url: data.repository
        };
      }
      var r = data.repository.url || "";
      if (r) {
        var hosted = hostedGitInfo.fromUrl(r);
        if (hosted) {
          r = data.repository.url = hosted.getDefaultRepresentation() == "shortcut" ? hosted.https() : hosted.toString();
        }
      }
      if (r.match(/github.com\/[^\/]+\/[^\/]+\.git\.git$/)) {
        this.warn("brokenGitUrl", r);
      }
    },
    fixTypos: function(data) {
      Object.keys(typos.topLevel).forEach(function(d) {
        if (data.hasOwnProperty(d)) {
          this.warn("typo", d, typos.topLevel[d]);
        }
      }, this);
    },
    fixScriptsField: function(data) {
      if (!data.scripts)
        return;
      if (typeof data.scripts !== "object") {
        this.warn("nonObjectScripts");
        delete data.scripts;
        return;
      }
      Object.keys(data.scripts).forEach(function(k) {
        if (typeof data.scripts[k] !== "string") {
          this.warn("nonStringScript");
          delete data.scripts[k];
        } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
          this.warn("typo", k, typos.script[k], "scripts");
        }
      }, this);
    },
    fixFilesField: function(data) {
      var files = data.files;
      if (files && !Array.isArray(files)) {
        this.warn("nonArrayFiles");
        delete data.files;
      } else if (data.files) {
        data.files = data.files.filter(function(file) {
          if (!file || typeof file !== "string") {
            this.warn("invalidFilename", file);
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixBinField: function(data) {
      if (!data.bin)
        return;
      if (typeof data.bin === "string") {
        var b = {};
        var match;
        if (match = data.name.match(/^@[^/]+[/](.*)$/)) {
          b[match[1]] = data.bin;
        } else {
          b[data.name] = data.bin;
        }
        data.bin = b;
      }
    },
    fixManField: function(data) {
      if (!data.man)
        return;
      if (typeof data.man === "string") {
        data.man = [data.man];
      }
    },
    fixBundleDependenciesField: function(data) {
      var bdd = "bundledDependencies";
      var bd = "bundleDependencies";
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd];
        delete data[bdd];
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        this.warn("nonArrayBundleDependencies");
        delete data[bd];
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function(bd2) {
          if (!bd2 || typeof bd2 !== "string") {
            this.warn("nonStringBundleDependency", bd2);
            return false;
          } else {
            if (!data.dependencies) {
              data.dependencies = {};
            }
            if (!data.dependencies.hasOwnProperty(bd2)) {
              this.warn("nonDependencyBundleDependency", bd2);
              data.dependencies[bd2] = "*";
            }
            return true;
          }
        }, this);
      }
    },
    fixDependencies: function(data, strict) {
      var loose = !strict;
      objectifyDeps(data, this.warn);
      addOptionalDepsToDeps(data, this.warn);
      this.fixBundleDependenciesField(data);
      ["dependencies", "devDependencies"].forEach(function(deps) {
        if (!(deps in data))
          return;
        if (!data[deps] || typeof data[deps] !== "object") {
          this.warn("nonObjectDependencies", deps);
          delete data[deps];
          return;
        }
        Object.keys(data[deps]).forEach(function(d) {
          var r = data[deps][d];
          if (typeof r !== "string") {
            this.warn("nonStringDependency", d, JSON.stringify(r));
            delete data[deps][d];
          }
          var hosted = hostedGitInfo.fromUrl(data[deps][d]);
          if (hosted)
            data[deps][d] = hosted.toString();
        }, this);
      }, this);
    },
    fixModulesField: function(data) {
      if (data.modules) {
        this.warn("deprecatedModules");
        delete data.modules;
      }
    },
    fixKeywordsField: function(data) {
      if (typeof data.keywords === "string") {
        data.keywords = data.keywords.split(/,\s+/);
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
        this.warn("nonArrayKeywords");
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function(kw) {
          if (typeof kw !== "string" || !kw) {
            this.warn("nonStringKeyword");
            return false;
          } else {
            return true;
          }
        }, this);
      }
    },
    fixVersionField: function(data, strict) {
      var loose = !strict;
      if (!data.version) {
        data.version = "";
        return true;
      }
      if (!semver.valid(data.version, loose)) {
        throw new Error('Invalid version: "' + data.version + '"');
      }
      data.version = semver.clean(data.version, loose);
      return true;
    },
    fixPeople: function(data) {
      modifyPeople(data, unParsePerson);
      modifyPeople(data, parsePerson);
    },
    fixNameField: function(data, options) {
      if (typeof options === "boolean")
        options = {strict: options};
      else if (typeof options === "undefined")
        options = {};
      var strict = options.strict;
      if (!data.name && !strict) {
        data.name = "";
        return;
      }
      if (typeof data.name !== "string") {
        throw new Error("name field must be a string.");
      }
      if (!strict)
        data.name = data.name.trim();
      ensureValidName(data.name, strict, options.allowLegacyCase);
      if (isBuiltinModule(data.name))
        this.warn("conflictingName", data.name);
    },
    fixDescriptionField: function(data) {
      if (data.description && typeof data.description !== "string") {
        this.warn("nonStringDescription");
        delete data.description;
      }
      if (data.readme && !data.description)
        data.description = extractDescription(data.readme);
      if (data.description === void 0)
        delete data.description;
      if (!data.description)
        this.warn("missingDescription");
    },
    fixReadmeField: function(data) {
      if (!data.readme) {
        this.warn("missingReadme");
        data.readme = "ERROR: No README data found!";
      }
    },
    fixBugsField: function(data) {
      if (!data.bugs && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.bugs()) {
          data.bugs = {url: hosted.bugs()};
        }
      } else if (data.bugs) {
        var emailRe = /^.+@.*\..+$/;
        if (typeof data.bugs == "string") {
          if (emailRe.test(data.bugs))
            data.bugs = {email: data.bugs};
          else if (url.parse(data.bugs).protocol)
            data.bugs = {url: data.bugs};
          else
            this.warn("nonEmailUrlBugsString");
        } else {
          bugsTypos(data.bugs, this.warn);
          var oldBugs = data.bugs;
          data.bugs = {};
          if (oldBugs.url) {
            if (typeof oldBugs.url == "string" && url.parse(oldBugs.url).protocol)
              data.bugs.url = oldBugs.url;
            else
              this.warn("nonUrlBugsUrlField");
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email == "string" && emailRe.test(oldBugs.email))
              data.bugs.email = oldBugs.email;
            else
              this.warn("nonEmailBugsEmailField");
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs;
          this.warn("emptyNormalizedBugs");
        }
      }
    },
    fixHomepageField: function(data) {
      if (!data.homepage && data.repository && data.repository.url) {
        var hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.docs())
          data.homepage = hosted.docs();
      }
      if (!data.homepage)
        return;
      if (typeof data.homepage !== "string") {
        this.warn("nonUrlHomepage");
        return delete data.homepage;
      }
      if (!url.parse(data.homepage).protocol) {
        data.homepage = "http://" + data.homepage;
      }
    },
    fixLicenseField: function(data) {
      if (!data.license) {
        return this.warn("missingLicense");
      } else {
        if (typeof data.license !== "string" || data.license.length < 1 || data.license.trim() === "") {
          this.warn("invalidLicense");
        } else {
          if (!validateLicense(data.license).validForNewPackages)
            this.warn("invalidLicense");
        }
      }
    }
  };
  function isValidScopedPackageName(spec) {
    if (spec.charAt(0) !== "@")
      return false;
    var rest = spec.slice(1).split("/");
    if (rest.length !== 2)
      return false;
    return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
  }
  function isCorrectlyEncodedName(spec) {
    return !spec.match(/[\/@\s\+%:]/) && spec === encodeURIComponent(spec);
  }
  function ensureValidName(name, strict, allowLegacyCase) {
    if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") {
      throw new Error("Invalid name: " + JSON.stringify(name));
    }
  }
  function modifyPeople(data, fn) {
    if (data.author)
      data.author = fn(data.author);
    ["maintainers", "contributors"].forEach(function(set2) {
      if (!Array.isArray(data[set2]))
        return;
      data[set2] = data[set2].map(fn);
    });
    return data;
  }
  function unParsePerson(person) {
    if (typeof person === "string")
      return person;
    var name = person.name || "";
    var u = person.url || person.web;
    var url2 = u ? " (" + u + ")" : "";
    var e = person.email || person.mail;
    var email = e ? " <" + e + ">" : "";
    return name + email + url2;
  }
  function parsePerson(person) {
    if (typeof person !== "string")
      return person;
    var name = person.match(/^([^\(<]+)/);
    var url2 = person.match(/\(([^\)]+)\)/);
    var email = person.match(/<([^>]+)>/);
    var obj = {};
    if (name && name[0].trim())
      obj.name = name[0].trim();
    if (email)
      obj.email = email[1];
    if (url2)
      obj.url = url2[1];
    return obj;
  }
  function addOptionalDepsToDeps(data, warn) {
    var o = data.optionalDependencies;
    if (!o)
      return;
    var d = data.dependencies || {};
    Object.keys(o).forEach(function(k) {
      d[k] = o[k];
    });
    data.dependencies = d;
  }
  function depObjectify(deps, type2, warn) {
    if (!deps)
      return {};
    if (typeof deps === "string") {
      deps = deps.trim().split(/[\n\r\s\t ,]+/);
    }
    if (!Array.isArray(deps))
      return deps;
    warn("deprecatedArrayDependencies", type2);
    var o = {};
    deps.filter(function(d) {
      return typeof d === "string";
    }).forEach(function(d) {
      d = d.trim().split(/(:?[@\s><=])/);
      var dn = d.shift();
      var dv = d.join("");
      dv = dv.trim();
      dv = dv.replace(/^@/, "");
      o[dn] = dv;
    });
    return o;
  }
  function objectifyDeps(data, warn) {
    depTypes.forEach(function(type2) {
      if (!data[type2])
        return;
      data[type2] = depObjectify(data[type2], type2, warn);
    });
  }
  function bugsTypos(bugs, warn) {
    if (!bugs)
      return;
    Object.keys(bugs).forEach(function(k) {
      if (typos.bugs[k]) {
        warn("typo", k, typos.bugs[k], "bugs");
        bugs[typos.bugs[k]] = bugs[k];
        delete bugs[k];
      }
    });
  }
});

// node_modules/normalize-package-data/lib/warning_messages.json
var require_warning_messages = __commonJS((exports2, module2) => {
  module2.exports = {
    repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
    missingRepository: "No repository field.",
    brokenGitUrl: "Probably broken git url: %s",
    nonObjectScripts: "scripts must be an object",
    nonStringScript: "script values must be string commands",
    nonArrayFiles: "Invalid 'files' member",
    invalidFilename: "Invalid filename in 'files' list: %s",
    nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
    nonStringBundleDependency: "Invalid bundleDependencies member: %s",
    nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
    nonObjectDependencies: "%s field must be an object",
    nonStringDependency: "Invalid dependency: %s %s",
    deprecatedArrayDependencies: "specifying %s as array is deprecated",
    deprecatedModules: "modules field is deprecated",
    nonArrayKeywords: "keywords should be an array of strings",
    nonStringKeyword: "keywords should be an array of strings",
    conflictingName: "%s is also the name of a node core module.",
    nonStringDescription: "'description' field should be a string",
    missingDescription: "No description",
    missingReadme: "No README data",
    missingLicense: "No license field.",
    nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
    nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
    nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
    emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
    nonUrlHomepage: "homepage field must be a string url. Deleted.",
    invalidLicense: "license should be a valid SPDX license expression",
    typo: "%s should probably be %s."
  };
});

// node_modules/normalize-package-data/lib/make_warning.js
var require_make_warning = __commonJS((exports2, module2) => {
  var util2 = require("util");
  var messages = require_warning_messages();
  module2.exports = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var warningName = args.shift();
    if (warningName == "typo") {
      return makeTypoWarning.apply(null, args);
    } else {
      var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
      args.unshift(msgTemplate);
      return util2.format.apply(null, args);
    }
  };
  function makeTypoWarning(providedName, probableName, field) {
    if (field) {
      providedName = field + "['" + providedName + "']";
      probableName = field + "['" + probableName + "']";
    }
    return util2.format(messages.typo, providedName, probableName);
  }
});

// node_modules/normalize-package-data/lib/normalize.js
var require_normalize = __commonJS((exports2, module2) => {
  module2.exports = normalize;
  var fixer = require_fixer();
  normalize.fixer = fixer;
  var makeWarning = require_make_warning();
  var fieldsToFix = [
    "name",
    "version",
    "description",
    "repository",
    "modules",
    "scripts",
    "files",
    "bin",
    "man",
    "bugs",
    "keywords",
    "readme",
    "homepage",
    "license"
  ];
  var otherThingsToFix = ["dependencies", "people", "typos"];
  var thingsToFix = fieldsToFix.map(function(fieldName) {
    return ucFirst(fieldName) + "Field";
  });
  thingsToFix = thingsToFix.concat(otherThingsToFix);
  function normalize(data, warn, strict) {
    if (warn === true)
      warn = null, strict = true;
    if (!strict)
      strict = false;
    if (!warn || data.private)
      warn = function(msg) {
      };
    if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) {
      data.gypfile = true;
    }
    fixer.warn = function() {
      warn(makeWarning.apply(null, arguments));
    };
    thingsToFix.forEach(function(thingName) {
      fixer["fix" + ucFirst(thingName)](data, strict);
    });
    data._id = data.name + "@" + data.version;
  }
  function ucFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
});

// node_modules/read-pkg/index.js
var require_read_pkg = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var loadJsonFile = require_load_json_file();
  var pathType = require_path_type();
  module2.exports = (fp, opts) => {
    if (typeof fp !== "string") {
      opts = fp;
      fp = ".";
    }
    opts = opts || {};
    return pathType.dir(fp).then((isDir) => {
      if (isDir) {
        fp = path5.join(fp, "package.json");
      }
      return loadJsonFile(fp);
    }).then((x) => {
      if (opts.normalize !== false) {
        require_normalize()(x);
      }
      return x;
    });
  };
  module2.exports.sync = (fp, opts) => {
    if (typeof fp !== "string") {
      opts = fp;
      fp = ".";
    }
    opts = opts || {};
    fp = pathType.dirSync(fp) ? path5.join(fp, "package.json") : fp;
    const x = loadJsonFile.sync(fp);
    if (opts.normalize !== false) {
      require_normalize()(x);
    }
    return x;
  };
});

// node_modules/read-pkg-up/index.js
var require_read_pkg_up = __commonJS((exports2, module2) => {
  "use strict";
  var findUp = require_find_up();
  var readPkg = require_read_pkg();
  module2.exports = (options) => {
    return findUp("package.json", options).then((fp) => {
      if (!fp) {
        return {};
      }
      return readPkg(fp, options).then((pkg) => ({pkg, path: fp}));
    });
  };
  module2.exports.sync = (options) => {
    const fp = findUp.sync("package.json", options);
    if (!fp) {
      return {};
    }
    return {
      pkg: readPkg.sync(fp, options),
      path: fp
    };
  };
});

// node_modules/@unibeautify/beautifier-prettydiff/dist/src/options.js
var require_options2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var commonOptions = {
    comments: [
      ["indent_comments"],
      (options2) => {
        if (options2.indent_comments === false) {
          return "noindent";
        } else {
          return "indent";
        }
      }
    ],
    inchar: [
      ["indent_style"],
      (options2) => {
        if (options2.indent_style === "tab") {
          return "	";
        } else if (options2.indent_style === "space") {
          return " ";
        }
      }
    ],
    insize: "indent_size",
    preserve: "max_preserve_newlines",
    quoteConvert: "quotes",
    wrap: "wrap_line_length"
  };
  var styleOptions = Object.assign({}, commonOptions, {noleadzero: "no_leading_zero", cssinsertlines: "newline_between_rules"});
  delete styleOptions.comments;
  var markupOptions = Object.assign({}, commonOptions, {force_indent: "force_indentation"});
  var scriptOptions = Object.assign({}, commonOptions, {endcomma: "end_with_comma", space: "space_after_anon_function", methodchain: [
    ["break_chained_methods"],
    (options2) => {
      return !(options2.break_chained_methods === true);
    }
  ], ternaryline: [
    ["multiline_ternary"],
    (options2) => {
      switch (options2.multiline_ternary) {
        case "always":
          return false;
        case "never":
          return true;
        default:
          return void 0;
      }
    }
  ], vertical: [
    ["align_assignments"],
    (options2) => {
      if (options2.align_assignments === true) {
        return "all";
      } else {
        return "none";
      }
    }
  ]});
  var scriptBasicOptions = Object.assign({}, scriptOptions);
  delete scriptBasicOptions.space;
  delete scriptBasicOptions.endcomma;
  var json5Options = Object.assign({}, commonOptions);
  delete json5Options.wrap;
  var jsonOptions = Object.assign({}, json5Options);
  delete jsonOptions.comments;
  var options = {
    Markup: markupOptions,
    Markdown: commonOptions,
    Script: scriptOptions,
    Style: styleOptions,
    JSON: jsonOptions,
    JSON5: json5Options,
    Common: commonOptions,
    BasicScript: scriptBasicOptions
  };
  exports2.default = options;
});

// node_modules/@unibeautify/beautifier-prettydiff/dist/src/index.js
var require_src3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var unibeautify_1 = require_src();
  var readPkgUp = require_read_pkg_up();
  var options_1 = require_options2();
  var {pkg} = readPkgUp.sync({cwd: __dirname});
  exports2.beautifier = {
    name: "Pretty Diff",
    package: pkg,
    dependencies: [
      {
        type: unibeautify_1.DependencyType.Node,
        name: "PrettyDiff",
        package: "prettydiff2"
      }
    ],
    options: {
      "C#": options_1.default.BasicScript,
      ColdFusion: options_1.default.Markup,
      CSS: options_1.default.Style,
      EJS: options_1.default.Script,
      Handlebars: options_1.default.Markup,
      HTML: options_1.default.Markup,
      "HTML+ERB": options_1.default.Markup,
      Java: options_1.default.BasicScript,
      JavaScript: options_1.default.Script,
      JSON: options_1.default.JSON,
      JSON5: options_1.default.JSON5,
      JSX: options_1.default.Script,
      Less: options_1.default.Style,
      Riot: options_1.default.Script,
      SCSS: options_1.default.Style,
      Spacebars: options_1.default.Markup,
      SVG: options_1.default.Markup,
      Swig: options_1.default.Script,
      "Titanium Style Sheets": options_1.default.Style,
      Twig: options_1.default.Script,
      TypeScript: options_1.default.Script,
      Visualforce: options_1.default.Markup,
      XML: options_1.default.Markup,
      XTemplate: options_1.default.Markup
    },
    beautify({text, options, language, dependencies}) {
      return new Promise((resolve, reject) => {
        const prettydiff = dependencies.get("PrettyDiff").package;
        let lang = "auto";
        switch (language.name) {
          case "EJS":
          case "Twig":
            lang = "ejs";
            break;
          case "HTML+ERB":
            lang = "html_ruby";
            break;
          case "Handlebars":
          case "Mustache":
          case "Spacebars":
          case "Swig":
          case "Riot.js":
          case "XTemplate":
            lang = "handlebars";
            break;
          case "SGML":
          case "XML":
          case "Visualforce":
          case "SVG":
            lang = "xml";
            break;
          case "HTML":
          case "Coldfusion":
            lang = "html";
            break;
          case "JavaScript":
            lang = "javascript";
            break;
          case "Java":
            lang = "java";
            break;
          case "JSON":
          case "JSON5":
            lang = "json";
            break;
          case "JSX":
            lang = "jsx";
            break;
          case "C#":
            lang = "cs";
            break;
          case "CSS":
            lang = "css";
            break;
          case "Less":
            lang = "less";
            break;
          case "SCSS":
          case "Sass":
            lang = "scss";
            break;
          case "Titanium Style Sheets":
            lang = "tss";
            break;
          case "TypeScript":
            lang = "ts";
            break;
          default:
            lang = "auto";
        }
        const args = Object.assign({}, options, {
          insize: options.insize || 2,
          source: text,
          lang,
          mode: "beautify"
        });
        const result = prettydiff(args);
        return resolve(result);
      });
    }
  };
  exports2.default = exports2.beautifier;
});

// node_modules/@unibeautify/beautifier-js-beautify/dist/src/options.js
var require_options3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var commonOptions = {
    indent_char: [
      ["indent_style"],
      (options2) => {
        if (options2.indent_style === "tab") {
          return "	";
        } else if (options2.indent_style === "space") {
          return " ";
        }
      }
    ]
  };
  var options = {
    JSON: Object.assign({}, commonOptions, {indent_size: true}),
    JavaScript: Object.assign({}, commonOptions, {
      indent_size: true,
      brace_style: true,
      preserve_newlines: true,
      unindent_chained_methods: [
        ["indent_chained_methods"],
        ({indent_chained_methods: val}) => val === true ? false : val === false ? true : val
      ],
      break_chained_methods: true,
      max_preserve_newlines: true,
      space_in_paren: true,
      space_in_empty_paren: true,
      jslint_happy: true,
      space_after_anon_function: true,
      keep_array_indentation: true,
      space_before_conditional: true,
      unescape_strings: true,
      wrap_line_length: true,
      end_with_newline: true,
      comma_first: true,
      keep_function_indentation: true
    }),
    HTML: Object.assign({}, commonOptions, {
      indent_size: true,
      brace_style: true,
      indent_inner_html: true,
      wrap_line_length: true,
      unformatted: true,
      indent_scripts: true,
      preserve_newlines: true,
      max_preserve_newlines: true,
      end_with_newline: true,
      extra_liners: "newline_before_tags",
      wrap_attributes: true,
      wrap_attributes_indent_size: true
    }),
    CSS: Object.assign({}, commonOptions, {indent_size: true, selector_separator_newline: true, newline_between_rules: true, preserve_newlines: true, wrap_line_length: true, end_with_newline: true})
  };
  exports2.default = options;
});

// node_modules/@unibeautify/beautifier-js-beautify/dist/src/index.js
var require_src4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var unibeautify_1 = require_src();
  var readPkgUp = require_read_pkg_up();
  var options_1 = require_options3();
  var {pkg} = readPkgUp.sync({cwd: __dirname});
  exports2.beautifier = {
    name: "JS-Beautify",
    package: pkg,
    dependencies: [
      {
        type: unibeautify_1.DependencyType.Node,
        name: "JS Beautify",
        package: "js-beautify"
      }
    ],
    options: {
      HTML: options_1.default.HTML,
      XML: options_1.default.HTML,
      Handlebars: options_1.default.HTML,
      Mustache: options_1.default.HTML,
      Liquid: options_1.default.HTML,
      JavaScript: options_1.default.JavaScript,
      EJS: options_1.default.JavaScript,
      JSX: options_1.default.JavaScript,
      JSON: options_1.default.JSON,
      JSON5: options_1.default.JSON,
      CSS: options_1.default.CSS
    },
    beautify({text, options, language, dependencies}) {
      return new Promise((resolve, reject) => {
        const jsbeautify = dependencies.get("JS Beautify").package;
        try {
          switch (language.name) {
            case "JSON":
            case "JSON5":
            case "JavaScript":
              return resolve(jsbeautify.js_beautify(text, options));
            case "JSX":
              options.e4x = true;
              options.es4 = true;
              return resolve(jsbeautify.js_beautify(text, options));
            case "Handlebars":
            case "Mustache":
              options.indent_handlebars = true;
              return resolve(jsbeautify.html_beautify(text, options));
            case "EJS":
            case "Liquid":
            case "HTML":
            case "XML":
              return resolve(jsbeautify.html_beautify(text, options));
            case "CSS":
              return resolve(jsbeautify.css_beautify(text, options));
            default:
              throw new Error("Unknown language for JS Beautify: " + language);
          }
        } catch (error) {
          return reject(error);
        }
      });
    }
  };
  exports2.default = exports2.beautifier;
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS((exports2) => {
  var pathModule = require("path");
  var isWindows = process.platform === "win32";
  var fs5 = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs5.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs5.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs5.statSync(base);
          linkTarget = fs5.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs5.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs5.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs5.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs5.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs5 = require("fs");
  var origRealpath = fs5.realpath;
  var origRealpathSync = fs5.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs5.realpath = realpath;
    fs5.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs5.realpath = origRealpath;
    fs5.realpathSync = origRealpathSync;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str2) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str2);
    if (b instanceof RegExp)
      b = maybeMatch(b, str2);
    var r = range(a, b, str2);
    return r && {
      start: r[0],
      end: r[1],
      pre: str2.slice(0, r[0]),
      body: str2.slice(r[0] + a.length, r[1]),
      post: str2.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str2) {
    var m = str2.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str2) {
    var begs, beg, left, right, result;
    var ai = str2.indexOf(a);
    var bi = str2.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str2.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str2.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str2.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str2);
    if (!m)
      return str2.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str2) {
    if (!str2)
      return [];
    if (str2.substr(0, 2) === "{}") {
      str2 = "\\{\\}" + str2.substr(2);
    }
    return expand(escapeBraces(str2), true).map(unescapeBraces);
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str2, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str2);
    if (!m || /\$$/.test(m.pre))
      return [str2];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str2 = m.pre + "{" + m.body + escClose + m.post;
        return expand(str2);
      }
      return [str2];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path5 = {sep: "/"};
  try {
    path5 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set2, c) {
      set2[c] = true;
      return set2;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m = function minimatch2(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path5.sep !== "/") {
      pattern = pattern.split(path5.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set2 = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set2);
    set2 = this.globParts = set2.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set2);
    set2 = set2.map(function(s, si, set3) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set2);
    set2 = set2.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set2);
    this.set = set2;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set2.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path5.sep !== "/") {
      f = f.split(path5.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set2 = this.set;
    this.debug(this.pattern, "set", set2);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set2.length; i++) {
      var pattern = set2[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util2 = require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util2;
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports2, module2) => {
  "use strict";
  function posix(path5) {
    return path5.charAt(0) === "/";
  }
  function win32(path5) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path5);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// node_modules/glob/common.js
var require_common = __commonJS((exports2) => {
  exports2.alphasort = alphasort;
  exports2.alphasorti = alphasorti;
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path5 = require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
  function alphasorti(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }
  function alphasort(a, b) {
    return a.localeCompare(b);
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path5.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path5.resolve(self2.cwd, "/");
    self2.root = path5.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m2) {
            all[m2] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(self2.nocase ? alphasorti : alphasort);
    if (self2.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m2) {
        return !isIgnored(self2, m2);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path5.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path5.resolve(self2.cwd, f);
    } else {
      abs = path5.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path6) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path6) || !!(item.gmatcher && item.gmatcher.match(path6));
    });
  }
  function childrenIgnored(self2, path6) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path6));
    });
  }
});

// node_modules/glob/sync.js
var require_sync3 = __commonJS((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs5 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util2 = require("util");
  var path5 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var common2 = require_common();
  var alphasort = common2.alphasort;
  var alphasorti = common2.alphasorti;
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common2.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path5.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs5.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs5.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path5.join(this.root, prefix);
      } else {
        prefix = path5.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs5.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs5.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args[i];
    return array;
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS((exports2, module2) => {
  module2.exports = glob;
  var fs5 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = require("events").EventEmitter;
  var path5 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync3();
  var common2 = require_common();
  var alphasort = common2.alphasort;
  var alphasorti = common2.alphasorti;
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var inflight = require_inflight();
  var util2 = require("util");
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend3(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend3({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set2 = g.minimatch.set;
    if (!pattern)
      return false;
    if (set2.length > 1)
      return true;
    for (var j = 0; j < set2[0].length; j++) {
      if (typeof set2[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common2.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set2[real] = true;
        else if (er.syscall === "stat")
          set2[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set2;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path5.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs5.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    fs5.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path5.join(this.root, prefix);
      } else {
        prefix = path5.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type2 = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type2 === "FILE")
          return cb();
        else
          return cb(null, type2, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      fs5.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs5.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var path5 = require("path");
  var fs5 = require("fs");
  var glob = void 0;
  try {
    glob = require_glob();
  } catch (_err) {
  }
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs5[m];
      m = m + "Sync";
      options[m] = options[m] || fs5[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf2 = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf2(path5.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (let i = 0; i < results.length; i++) {
      const p2 = results[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path5.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module2.exports = rimraf2;
  rimraf2.sync = rimrafSync;
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc7 = __toModule(require("coc.nvim"));
var import_fs4 = __toModule(require("fs"));
var import_which2 = __toModule(require_which());

// src/format.ts
var import_coc3 = __toModule(require("coc.nvim"));

// src/formatter/djhtml.ts
var import_coc = __toModule(require("coc.nvim"));
var import_child_process = __toModule(require("child_process"));

// package.json
var djhtmlVersion = "1.4.9";

// src/constant.ts
var SUPPORT_LANGUAGES = ["htmldjango"];
var DJHTML_VERSION = djhtmlVersion;

// src/tool.ts
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_which = __toModule(require_which());
function whichCmd(cmd) {
  try {
    return import_which.default.sync(cmd);
  } catch (error) {
    return "";
  }
}
function resolveDjhtmlPath(context, toolPath) {
  if (!toolPath) {
    const whichDjhtml = whichCmd("djhtml");
    if (whichDjhtml) {
      toolPath = whichDjhtml;
    } else if (import_fs.default.existsSync(import_path.default.join(context.storagePath, "djhtml", "venv", "Scripts", "djhtml.exe")) || import_fs.default.existsSync(import_path.default.join(context.storagePath, "djhtml", "venv", "bin", "djhtml"))) {
      if (process.platform === "win32") {
        toolPath = import_path.default.join(context.storagePath, "djhtml", "venv", "Scripts", "djhtml.exe");
      } else {
        toolPath = import_path.default.join(context.storagePath, "djhtml", "venv", "bin", "djhtml");
      }
    } else {
      toolPath = "";
    }
  }
  return toolPath;
}

// src/formatter/djhtml.ts
async function doDjhtmlFormat(context, outputChannel, document, range) {
  if (!SUPPORT_LANGUAGES.includes(document.languageId)) {
    throw '"djhtml" cannot run, not supported language';
  }
  const extensionConfig = import_coc.workspace.getConfiguration("htmldjango");
  const text = document.getText(range);
  const fileName = import_coc.Uri.parse(document.uri).fsPath;
  let djhtmlPath = extensionConfig.get("djhtml.commandPath", "");
  djhtmlPath = resolveDjhtmlPath(context, djhtmlPath);
  if (!djhtmlPath) {
    import_coc.window.showErrorMessage('Unable to find the "djhtml" command.');
    return text;
  }
  const tabwidth = extensionConfig.get("djhtml.tabWidth", 4);
  const args = [];
  const cwd = import_coc.Uri.file(import_coc.workspace.root).fsPath;
  const opts = {cwd, shell: true};
  args.push("--tabwidth", tabwidth.toString());
  args.push("-");
  outputChannel.appendLine(`${"#".repeat(10)} djhtml
`);
  outputChannel.appendLine(`Cwd: ${opts.cwd}`);
  outputChannel.appendLine(`File: ${fileName}`);
  outputChannel.appendLine(`Run: ${djhtmlPath} ${args.join(" ")}`);
  return new Promise((resolve) => {
    const cps = import_child_process.default.spawn(djhtmlPath, args, opts);
    cps.on("error", (err) => {
      outputChannel.appendLine(`
==== ERROR ===
`);
      outputChannel.appendLine(`${err}`);
      return;
    });
    if (cps.pid) {
      cps.stdin.write(text);
      cps.stdin.end();
      cps.stderr.on("data", (data) => {
        outputChannel.appendLine(`
==== STDERR ===
`);
        outputChannel.appendLine(`${data}`);
        resolve(text);
      });
      cps.stdout.on("data", (data) => {
        outputChannel.appendLine(`
==== STDOUT ===
`);
        outputChannel.appendLine(`${data}`);
        resolve(data.toString());
      });
    }
  });
}

// src/formatter/unibeautify.ts
var import_coc2 = __toModule(require("coc.nvim"));
var import_fs2 = __toModule(require("fs"));
var import_path2 = __toModule(require("path"));
var import_unibeautify = __toModule(require_src());

// node_modules/js-yaml/dist/js-yaml.mjs
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({"": value}, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// src/formatter/unibeautify.ts
var import_beautifier_prettydiff = __toModule(require_src3());
var import_beautifier_js_beautify = __toModule(require_src4());
var beautifiers = [import_beautifier_js_beautify.default, import_beautifier_prettydiff.default];
async function doUnibeautifyFormat(context, outputChannel, document, range) {
  const extensionConfig = import_coc2.workspace.getConfiguration("htmldjango");
  const fileName = import_coc2.Uri.parse(document.uri).fsPath;
  const text = document.getText(range);
  let htmlLanguageOptions;
  const configFile = existsConfigFile();
  if (configFile.exists) {
    htmlLanguageOptions = loadConfigFile(configFile.filePath, configFile.fileType);
  } else {
    htmlLanguageOptions = {
      brace_style: extensionConfig.get("unibeautify.brace_style"),
      end_with_newline: extensionConfig.get("unibeautify.end_with_newline"),
      force_indentation: extensionConfig.get("unibeautify.force_indentation"),
      indent_comments: extensionConfig.get("unibeautify.indent_comments"),
      indent_inner_html: extensionConfig.get("unibeautify.indent_inner_html"),
      indent_scripts: extensionConfig.get("unibeautify.indent_scripts"),
      indent_size: extensionConfig.get("unibeautify.indent_size"),
      indent_style: extensionConfig.get("unibeautify.indent_style"),
      max_preserve_newlines: extensionConfig.get("unibeautify.max_preserve_newlines"),
      newline_before_tags: extensionConfig.get("unibeautify.newline_before_tags"),
      preserve_newlines: extensionConfig.get("unibeautify.preserve_newlines"),
      quotes: extensionConfig.get("unibeautify.quotes"),
      unformatted: extensionConfig.get("unibeautify.unformatted"),
      wrap_attributes: extensionConfig.get("unibeautify.wrap_attributes"),
      wrap_attributes_indent_size: extensionConfig.get("unibeautify.wrap_attributes_indent_size"),
      wrap_line_length: extensionConfig.get("unibeautify.wrap_line_length")
    };
  }
  import_unibeautify.default.loadBeautifiers(beautifiers);
  const beautifyData = {
    text,
    filePath: fileName,
    projectPath: import_coc2.workspace.root,
    options: {
      ["HTML"]: htmlLanguageOptions
    },
    languageName: "HTML",
    fileExtension: ".html"
  };
  outputChannel.appendLine(`${"#".repeat(10)} unibeautify
`);
  outputChannel.appendLine(`File: ${fileName}`);
  return safeExecution(() => {
    return import_unibeautify.default.beautify(beautifyData);
  }, text, fileName, outputChannel);
}
function safeExecution(cb, defaultText, fileName, outputChannel) {
  if (cb instanceof Promise) {
    return cb.then((returnValue) => {
      return returnValue;
    }).catch((err) => {
      outputChannel.appendLine(`
==== ERR ===
`);
      outputChannel.appendLine(`${err}`);
      console.error(fileName, err);
      return defaultText;
    });
  }
  try {
    outputChannel.appendLine("");
    return cb();
  } catch (err) {
    outputChannel.appendLine(`
==== ERR ===
`);
    outputChannel.appendLine(`${err}`);
    console.error(fileName, err);
    return defaultText;
  }
}
function existsConfigFile() {
  const r = {
    exists: false,
    filePath: "",
    fileType: "none"
  };
  const workspaceRootDir = import_coc2.Uri.file(import_coc2.workspace.root).fsPath;
  if (import_fs2.default.existsSync(import_path2.default.join(workspaceRootDir, ".unibeautifyrc.yml"))) {
    r.exists = true;
    r.filePath = import_path2.default.join(workspaceRootDir, ".unibeautifyrc.yml");
    r.fileType = "yaml";
  } else if (import_fs2.default.existsSync(import_path2.default.join(workspaceRootDir, ".unibeautifyrc.yaml"))) {
    r.exists = true;
    r.filePath = import_path2.default.join(workspaceRootDir, ".unibeautifyrc.yaml");
    r.fileType = "yaml";
  } else if (import_fs2.default.existsSync(import_path2.default.join(workspaceRootDir, ".unibeautifyrc.json"))) {
    r.exists = true;
    r.filePath = import_path2.default.join(workspaceRootDir, ".unibeautifyrc.json");
    r.fileType = "json";
  }
  return r;
}
function loadConfigFile(filePath, fileType) {
  let options = {};
  if (!import_fs2.default.existsSync(filePath) || fileType === "none") {
    return options;
  }
  if (fileType === "yaml") {
    try {
      const configData = js_yaml_default.load(import_fs2.default.readFileSync(filePath, "utf8"));
      if (configData && typeof configData === "object") {
        options = parseConfigData(configData["HTML"]);
      }
    } catch (e) {
      return options;
    }
  }
  if (fileType === "json") {
    try {
      const configData = JSON.parse(import_fs2.default.readFileSync(filePath, "utf8"));
      if (configData && typeof configData === "object") {
        options = parseConfigData(configData["HTML"]);
      }
    } catch (e) {
      return options;
    }
  }
  return options;
}
function parseConfigData(dataObj) {
  const optionKeyList = [
    "brace_style",
    "end_with_newline",
    "force_indentation",
    "indent_comments",
    "indent_inner_html",
    "indent_scripts",
    "indent_size",
    "indent_style",
    "max_preserve_newlines",
    "newline_before_tags",
    "preserve_newlines",
    "quotes",
    "unformatted",
    "wrap_attributes",
    "wrap_attributes_indent_size",
    "wrap_line_length"
  ];
  const options = {};
  for (const item of optionKeyList) {
    if (item in dataObj) {
      options[item] = dataObj[item];
    }
  }
  return options;
}

// src/format.ts
function fullDocumentRange(document) {
  const lastLineId = document.lineCount - 1;
  const doc = import_coc3.workspace.getDocument(document.uri);
  return import_coc3.Range.create({character: 0, line: 0}, {character: doc.getline(lastLineId).length, line: lastLineId});
}
var HtmlDjangoFormattingEditProvider = class {
  constructor(context, outputChannel) {
    this._context = context;
    this._outputChannel = outputChannel;
  }
  provideDocumentFormattingEdits(document) {
    return this._provideEdits(document, void 0);
  }
  provideDocumentRangeFormattingEdits(document, range) {
    return this._provideEdits(document, range);
  }
  getFormatFunc(formatter) {
    let formatterFunc;
    formatterFunc = doDjhtmlFormat;
    if (formatter) {
      if (formatter === "unibeautify") {
        formatterFunc = doUnibeautifyFormat;
      } else if (formatter === "djhtml") {
        formatterFunc = doDjhtmlFormat;
      }
    } else {
      const extensionConfig = import_coc3.workspace.getConfiguration("htmldjango");
      const formattingProvider = extensionConfig.get("formatting.provider", "djhtml");
      if (formattingProvider === "unibeautify") {
        formatterFunc = doUnibeautifyFormat;
      } else if (formattingProvider === "djhtml") {
        formatterFunc = doDjhtmlFormat;
      }
    }
    return formatterFunc;
  }
  async _provideEdits(document, range) {
    const doFormat = this.getFormatFunc();
    const code = await doFormat(this._context, this._outputChannel, document, range);
    if (!range) {
      range = fullDocumentRange(document);
    }
    return [import_coc3.TextEdit.replace(range, code)];
  }
};
var format_default = HtmlDjangoFormattingEditProvider;

// src/hover.ts
var import_coc4 = __toModule(require("coc.nvim"));
var import_fs3 = __toModule(require("fs"));
var import_path3 = __toModule(require("path"));

// src/hoverLang.ts
var djangoHovers = [
  {
    prefix: "autoescape",
    alias: ["endautoescape"]
  },
  {
    prefix: "block",
    alias: ["endblock"]
  },
  {
    prefix: "comment",
    alias: ["endcomment"]
  },
  {
    prefix: "csrf_token",
    alias: []
  },
  {
    prefix: "cycle",
    alias: []
  },
  {
    prefix: "debug",
    alias: []
  },
  {
    prefix: "extends",
    alias: []
  },
  {
    prefix: "filter",
    alias: ["endfilter"]
  },
  {
    prefix: "firstof",
    alias: []
  },
  {
    prefix: "for",
    alias: ["endfor"]
  },
  {
    prefix: "empty",
    alias: []
  },
  {
    prefix: "if",
    alias: ["elif", "else", "endif"]
  },
  {
    prefix: "ifchanged",
    alias: ["endifchanged"]
  },
  {
    prefix: "include",
    alias: []
  },
  {
    prefix: "load",
    alias: []
  },
  {
    prefix: "lorem",
    alias: []
  },
  {
    prefix: "now",
    alias: []
  },
  {
    prefix: "regroup",
    alias: []
  },
  {
    prefix: "resetcycle",
    alias: []
  },
  {
    prefix: "spaceless",
    alias: []
  },
  {
    prefix: "templatetag",
    alias: []
  },
  {
    prefix: "url",
    alias: []
  },
  {
    prefix: "verbatim",
    alias: []
  },
  {
    prefix: "widthratio",
    alias: []
  },
  {
    prefix: "with",
    alias: []
  },
  {
    prefix: "add",
    alias: []
  },
  {
    prefix: "addslashes",
    alias: []
  },
  {
    prefix: "capfirst",
    alias: []
  },
  {
    prefix: "center",
    alias: []
  },
  {
    prefix: "cut",
    alias: []
  },
  {
    prefix: "date",
    alias: []
  },
  {
    prefix: "default",
    alias: []
  },
  {
    prefix: "default_if_none",
    alias: []
  },
  {
    prefix: "dictsort",
    alias: []
  },
  {
    prefix: "dictsortreversed",
    alias: []
  },
  {
    prefix: "divisibleby",
    alias: []
  },
  {
    prefix: "escape",
    alias: []
  },
  {
    prefix: "escapejs",
    alias: []
  },
  {
    prefix: "filesizeformat",
    alias: []
  },
  {
    prefix: "first",
    alias: []
  },
  {
    prefix: "floatformat",
    alias: []
  },
  {
    prefix: "force_escape",
    alias: []
  },
  {
    prefix: "get_digit",
    alias: []
  },
  {
    prefix: "iriencode",
    alias: []
  },
  {
    prefix: "join",
    alias: []
  },
  {
    prefix: "json_script",
    alias: []
  },
  {
    prefix: "last",
    alias: []
  },
  {
    prefix: "length",
    alias: []
  },
  {
    prefix: "length_is",
    alias: []
  },
  {
    prefix: "linebreaks",
    alias: []
  },
  {
    prefix: "linebreaksbr",
    alias: []
  },
  {
    prefix: "linenumbers",
    alias: []
  },
  {
    prefix: "ljust",
    alias: []
  },
  {
    prefix: "lower",
    alias: []
  },
  {
    prefix: "make_list",
    alias: []
  },
  {
    prefix: "phone2numeric",
    alias: []
  },
  {
    prefix: "pluralize",
    alias: []
  },
  {
    prefix: "pprint",
    alias: []
  },
  {
    prefix: "random",
    alias: []
  },
  {
    prefix: "rjust",
    alias: []
  },
  {
    prefix: "safe",
    alias: []
  },
  {
    prefix: "safeseq",
    alias: []
  },
  {
    prefix: "slice",
    alias: []
  },
  {
    prefix: "slugify",
    alias: []
  },
  {
    prefix: "stringformat",
    alias: []
  },
  {
    prefix: "striptags",
    alias: []
  },
  {
    prefix: "time",
    alias: []
  },
  {
    prefix: "timesince",
    alias: []
  },
  {
    prefix: "timeuntil",
    alias: []
  },
  {
    prefix: "title",
    alias: []
  },
  {
    prefix: "truncatechars",
    alias: []
  },
  {
    prefix: "truncatechars_html",
    alias: []
  },
  {
    prefix: "truncatewords",
    alias: []
  },
  {
    prefix: "truncatewords_html",
    alias: []
  },
  {
    prefix: "unordered_list",
    alias: []
  },
  {
    prefix: "upper",
    alias: []
  },
  {
    prefix: "urlencode",
    alias: []
  },
  {
    prefix: "urlize",
    alias: []
  },
  {
    prefix: "urlizetrunc",
    alias: []
  },
  {
    prefix: "wordcount",
    alias: []
  },
  {
    prefix: "wordwrap",
    alias: []
  },
  {
    prefix: "yesno",
    alias: []
  },
  {
    prefix: "i18n",
    alias: []
  },
  {
    prefix: "l10n",
    alias: []
  },
  {
    prefix: "tz",
    alias: []
  },
  {
    prefix: "static",
    alias: []
  },
  {
    prefix: "get_static_prefix",
    alias: []
  },
  {
    prefix: "get_media_prefix",
    alias: []
  }
];
var jinja2Hovers = [];

// src/hover.ts
var HtmlDjangoHoverProvider = class {
  constructor(context) {
    this.context = context;
    const extensionConfig = import_coc4.workspace.getConfiguration("htmldjango");
    this.hoverLang = extensionConfig.get("hoverLang", "django");
  }
  async provideHover(document, position) {
    const doc = import_coc4.workspace.getDocument(document.uri);
    if (!doc)
      return null;
    const wordRange = doc.getWordRangeAtPosition(position);
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    const result = await this.getHover(text, this.hoverLang);
    if (!result)
      return null;
    return {
      contents: {
        kind: "markdown",
        value: result
      }
    };
  }
  async getHover(text, hoverLang) {
    let defineHovers = djangoHovers;
    if (hoverLang === "django") {
      defineHovers = djangoHovers;
    } else if (hoverLang === "jinja2") {
      defineHovers = jinja2Hovers;
    } else {
      defineHovers = djangoHovers;
    }
    let result = "";
    for (const h in defineHovers) {
      if (text === defineHovers[h].prefix || defineHovers[h].alias.includes(text)) {
        const markdownPath = import_path3.default.join(this.context.extensionPath, "data", "hover", hoverLang, defineHovers[h].prefix + ".md");
        try {
          result = import_fs3.default.readFileSync(markdownPath, {encoding: "utf8"});
        } catch (e) {
          return result;
        }
        break;
      }
    }
    return result;
  }
};

// src/installer.ts
var import_coc5 = __toModule(require("coc.nvim"));
var import_path4 = __toModule(require("path"));
var import_rimraf = __toModule(require_rimraf());
var import_child_process2 = __toModule(require("child_process"));
var import_util = __toModule(require("util"));
var exec = import_util.default.promisify(import_child_process2.default.exec);
async function djhtmlInstall(pythonCommand, context) {
  const pathVenv = import_path4.default.join(context.storagePath, "djhtml", "venv");
  let pathVenvPython = import_path4.default.join(context.storagePath, "djhtml", "venv", "bin", "python");
  if (process.platform === "win32") {
    pathVenvPython = import_path4.default.join(context.storagePath, "djhtml", "venv", "Scripts", "python");
  }
  const statusItem = import_coc5.window.createStatusBarItem(0, {progress: true});
  statusItem.text = `Install djhtml...`;
  statusItem.show();
  const installCmd = `${pythonCommand} -m venv ${pathVenv} && ${pathVenvPython} -m pip install -U pip djhtml==${DJHTML_VERSION}`;
  import_rimraf.default.sync(pathVenv);
  try {
    import_coc5.window.showMessage(`Install djhtml...`);
    await exec(installCmd);
    statusItem.hide();
    import_coc5.window.showMessage(`djhtml: installed!`);
  } catch (error) {
    statusItem.hide();
    import_coc5.window.showErrorMessage(`djhtml: install failed. | ${error}`);
    throw new Error();
  }
}

// src/action.ts
var import_coc6 = __toModule(require("coc.nvim"));
var HtmlDjangoCodeActionProvider = class {
  async provideCodeActions(document, range, context) {
    const doc = import_coc6.workspace.getDocument(document.uri);
    const wholeRange = import_coc6.Range.create(0, 0, doc.lineCount, 0);
    let whole = false;
    if (range.start.line === wholeRange.start.line && range.start.character === wholeRange.start.character && range.end.line === wholeRange.end.line && range.end.character === wholeRange.end.character) {
      whole = true;
    }
    const codeActions = [];
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{# fmt:off #}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{# fmt:off #}\n" + addIndentSpace;
      }
      const edit = import_coc6.TextEdit.insert(import_coc6.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: "Add {# fmt:off #} for this line",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{# fmt:on #}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{# fmt:on #}\n" + addIndentSpace;
      }
      const edit = import_coc6.TextEdit.insert(import_coc6.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: "Add {# fmt:on #} for this line",
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    return codeActions;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
};

// src/index.ts
var formatterHandler;
var rangeFormatterHandler;
function disposeHandlers() {
  if (formatterHandler) {
    formatterHandler.dispose();
  }
  if (rangeFormatterHandler) {
    rangeFormatterHandler.dispose();
  }
  formatterHandler = void 0;
  rangeFormatterHandler = void 0;
}
function selectors() {
  const languageSelector = [{language: "htmldjango", scheme: "file"}];
  const rangeLanguageSelector = [{language: "htmldjango", scheme: "file"}];
  return {
    languageSelector,
    rangeLanguageSelector
  };
}
async function activate(context) {
  const {subscriptions} = context;
  const extensionConfig = import_coc7.workspace.getConfiguration("htmldjango");
  const isEnable = extensionConfig.get("enable", true);
  if (!isEnable)
    return;
  const extensionStoragePath = context.storagePath;
  if (!import_fs4.default.existsSync(extensionStoragePath)) {
    import_fs4.default.mkdirSync(extensionStoragePath);
  }
  const outputChannel = import_coc7.window.createOutputChannel("htmldjango");
  const isRealpath = true;
  const pythonCommand = getPythonPath(extensionConfig, isRealpath);
  subscriptions.push(import_coc7.commands.registerCommand("htmldjango.djhtml.install", async () => {
    await installWrapper(pythonCommand, context);
  }));
  const formattingProvider = extensionConfig.get("formatting.provider", "djhtml");
  let djhtmlPath = extensionConfig.get("djhtml.commandPath", "");
  djhtmlPath = resolveDjhtmlPath(context, djhtmlPath);
  if (formattingProvider === "djhtml") {
    if (!djhtmlPath) {
      if (pythonCommand) {
        await installWrapper(pythonCommand, context);
      }
    }
  }
  const editProvider = new format_default(context, outputChannel);
  const priority = 1;
  if (formattingProvider === "unibeautify" || formattingProvider === "djhtml") {
    let registerFormatter = function() {
      disposeHandlers();
      const {languageSelector: languageSelector2, rangeLanguageSelector} = selectors();
      rangeFormatterHandler = import_coc7.languages.registerDocumentRangeFormatProvider(rangeLanguageSelector, editProvider, priority);
      formatterHandler = import_coc7.languages.registerDocumentFormatProvider(languageSelector2, editProvider, priority);
    };
    registerFormatter();
  }
  subscriptions.push(import_coc7.commands.registerCommand("htmldjango.unibeautify.format", async () => {
    const doc = await import_coc7.workspace.document;
    const doFormat = editProvider.getFormatFunc("unibeautify");
    const code = await doFormat(context, outputChannel, doc.textDocument, void 0);
    const edits = [import_coc7.TextEdit.replace(fullDocumentRange(doc.textDocument), code)];
    if (edits) {
      await doc.applyEdits(edits);
    }
  }));
  subscriptions.push(import_coc7.commands.registerCommand("htmldjango.djhtml.format", async () => {
    const doc = await import_coc7.workspace.document;
    const doFormat = editProvider.getFormatFunc("djhtml");
    const code = await doFormat(context, outputChannel, doc.textDocument, void 0);
    const edits = [import_coc7.TextEdit.replace(fullDocumentRange(doc.textDocument), code)];
    if (edits) {
      await doc.applyEdits(edits);
    }
  }));
  context.subscriptions.push(import_coc7.languages.registerHoverProvider(["htmldjango"], new HtmlDjangoHoverProvider(context)));
  const languageSelector = [{language: "htmldjango", scheme: "file"}];
  const codeActionProvider = new HtmlDjangoCodeActionProvider();
  context.subscriptions.push(import_coc7.languages.registerCodeActionProvider(languageSelector, codeActionProvider, "htmldjango"));
}
async function installWrapper(pythonCommand, context) {
  const msg = 'Install/Upgrade "djhtml"?';
  context.workspaceState;
  let ret = 0;
  ret = await import_coc7.window.showQuickpick(["Yes", "Cancel"], msg);
  if (ret === 0) {
    try {
      await djhtmlInstall(pythonCommand, context);
    } catch (e) {
      return;
    }
  } else {
    return;
  }
}
function getPythonPath(config, isRealpath) {
  let pythonPath = config.get("builtin.pythonPath", "");
  if (pythonPath) {
    return pythonPath;
  }
  try {
    pythonPath = import_which2.default.sync("python3");
    if (isRealpath) {
      pythonPath = import_fs4.default.realpathSync(pythonPath);
    }
    return pythonPath;
  } catch (e) {
  }
  try {
    pythonPath = import_which2.default.sync("python");
    if (isRealpath) {
      pythonPath = import_fs4.default.realpathSync(pythonPath);
    }
    return pythonPath;
  } catch (e) {
  }
  return pythonPath;
}
